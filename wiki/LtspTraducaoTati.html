<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:fb="http://www.facebook.com/2008/fbml" xmlns="http://www.w3.org/1999/xhtml" xml:lang="pt-br" lang="pt-br" dir="ltr">


<!-- Mirrored from rede.metareciclagem.org/wiki/LtspTraducaoTati by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 23 Mar 2016 23:42:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>LtspTraducaoTati | MetaReciclagem</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="../sites/rede.metareciclagem.org/midia/metarec_favicon.png" type="image/x-icon" />
  <link type="text/css" rel="stylesheet" media="all" href="../modules/aggregator/aggregatore358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../modules/node/nodee358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../modules/system/defaultse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../modules/system/systeme358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../modules/system/system-menuse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../modules/user/usere358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/all/modules/cck/theme/content-modulee358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/all/modules/ckeditor/ckeditore358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/all/modules/ctools/css/ctoolse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/all/modules/mollom/mollome358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/modules/contrib/og/theme/oge358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/modules/contrib/tagadelic/tagadelice358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/all/modules/cck/modules/fieldgroup/fieldgroupe358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/all/modules/views/css/viewse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/modules/contrib/panels/css/panelse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../modules/comment/commente358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/html-resete358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/layout-fixede358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/tabse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/messagese358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/pagese358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/block-editinge358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/blockse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/nodese358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/commentse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/formse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/metarece358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/sidebarse358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/menue358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/footere358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/bloge358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/conectazese358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/wikie358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/esporose358.css?t" />
<link type="text/css" rel="stylesheet" media="all" href="../sites/rede.metareciclagem.org/themes/metarec/css/navigatione358.css?t" />
<link type="text/css" rel="stylesheet" media="screen" href="../sites/rede.metareciclagem.org/modules/contrib/iconizer/files_iconse358.css?t" />
<link type="text/css" rel="stylesheet" media="print" href="../sites/rede.metareciclagem.org/themes/metarec/css/printe358.css?t" />
<!--[if IE]>
<link type="text/css" rel="stylesheet" media="all" href="/sites/rede.metareciclagem.org/themes/metarec/css/ie.css?t" />
<![endif]-->
<!--[if lte IE 6]>
<link type="text/css" rel="stylesheet" media="all" href="/sites/rede.metareciclagem.org/themes/metarec/css/ie6.css?t" />
<![endif]-->
  <script type="text/javascript" src="../misc/jquerye358.js?t"></script>
<script type="text/javascript" src="../misc/drupale358.js?t"></script>
<script type="text/javascript" src="../sites/rede.metareciclagem.org/midia/languages/pt-br_dde38addaa4a41db1bd84fb265499402e358.js?t"></script>
<script type="text/javascript" src="../sites/rede.metareciclagem.org/modules/contrib/og/oge358.js?t"></script>
<script type="text/javascript" src="../sites/rede.metareciclagem.org/modules/contrib/panels/js/panelse358.js?t"></script>
<script type="text/javascript" src="../sites/all/modules/google_analytics/googleanalyticse358.js?t"></script>
<script type="text/javascript">
<!--//--><![CDATA[//><!--
jQuery.extend(Drupal.settings, { "basePath": "/", "googleanalytics": { "trackOutbound": 1, "trackMailto": 1, "trackDownload": 1, "trackDownloadExtensions": "7z|aac|arc|arj|asf|asx|avi|bin|csv|doc(x|m)?|dot(x|m)?|exe|flv|gif|gz|gzip|hqx|jar|jpe?g|js|mp(2|3|4|e?g)|mov(ie)?|msi|msp|pdf|phps|png|ppt(x|m)?|pot(x|m)?|pps(x|m)?|ppam|sld(x|m)?|thmx|qtm?|ra(m|r)?|sea|sit|tar|tgz|torrent|txt|wav|wma|wmv|wpd|xls(x|m|b)?|xlt(x|m)|xlam|xml|z|zip" } });
//--><!]]>
</script>
<script type="text/javascript">
<!--//--><![CDATA[//><!--
(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","http://www.google-analytics.com/analytics.js","ga");ga("create", "UA-126845-3", { "cookieDomain": "auto" });ga("set", "anonymizeIp", true);ga("send", "pageview");
//--><!]]>
</script>
</head>
<body class="page not-front not-logged-in node-type-wiki page-wiki-ltsptraducaotati section-wiki one-sidebar sidebar-second page-panels">

      <div id="skip-to-nav"><a href="#main-menu">Jump to Navigation</a></div>
  
  <div id="header-wrapper"><div id="header"><div class="section clearfix">

              <a href="../index.html" title="Home" rel="home" id="logo"><img src="../sites/rede.metareciclagem.org/midia/metarec_logo.png" alt="Home" /></a>
      
      
      
      
              <div class="section clearfix">
        
          <ul id="main-menu" class="links clearfix"><li class="menu-212 first"><a href="../blog.html" title="Blog da rede MetaReciclagem">Blog</a></li>
<li class="menu-99"><a href="InicioWiki.html" title="Wiki">Wiki</a></li>
<li class="menu-115"><a href="../profile.html">Pessoas</a></li>
<li class="menu-163"><a href="../listas/conectazes.html" title="Lista de ConecTAZes">ConecTAZes</a></li>
<li class="menu-164"><a href="../listas/esporos.html" title="Esporos">Esporos</a></li>
<li class="menu-107"><a href="https://web.archive.org/web/20120424170845/http://links.metareciclagem.org:80/" title="Banco de links da MetaReciclagem">Links</a></li>
<li class="menu-98 last"><a href="../contato.html" title="Fale com a MetaReciclagem">Contato</a></li>
</ul>          
        </div> <!-- /.section, /#navigation -->
            
      
  </div></div></div> <!-- /.section, /#header -->
  
        <div id="navigation-wrapper"><div id="navigation"><div class="section clearfix">

          
      
    </div></div></div> <!-- /.section, /#navigation -->
    
  

  <div id="page-wrapper"><div id="page">
    <div id="main-wrapper">

    <div id="main" class="clearfix with-navigation">

      <div id="content" class="column">
      
      <div class="breadcrumb"><a href="../index.html">Home</a> › <a href="../node.html">Conteúdo</a> › </div>      
      <div class="section">

        
        
        
                  <h1 class="title">LtspTraducaoTati</h1>
                                
        
        <div id="content-area">
          <div id="node-1340" class="node node-type-wiki build-mode-full clearfix">
  
  
  
      <div class="meta">
              <span class="submitted">
          Enviado por <a href="../pessoa/felipefonseca.html" title="Ver perfil dx usuárix.">felipefonseca</a> em sex, 20/06/2008 - 10:11.        </span>
      
              <div class="terms terms-inline"><ul class="links inline"><li class="taxonomy_term_291 first"><a href="../assunto/ltsp.html" rel="tag" title="">ltsp</a></li>
<li class="taxonomy_term_161 last"><a href="../tags/software-livre.html" rel="tag" title="">software livre</a></li>
</ul></div>
          </div>
  
  <div class="content">
    <p><a href="LTSP.html" title="" class="freelink freelink-nodetitle freelink-internal" rel="nofollow">LTSP</a></p><p>&nbsp;</p><p>:: Documenta&ccedil;&atilde;o do LTSP v4.1<br />por James McQuillan -&gt; <a href="mailto:jam@LTSP.org" rel="nofollow">jam@LTSP.org</a><br />Tradu&ccedil;&atilde;o de Gravim (PSL-BA) e Tatiana Wells (MetaReciclagem.org)<br />Copyright &copy; 2004 by James A. McQuillan<br />GNU/Linux &eacute; uma excelente plataforma para acionar terminais leves sem disco r&iacute;gido. O prop&oacute;sito deste documento &eacute; mostrar como fazer isto, usando a tecnologia LTSP. Al&eacute;m disso, este documento trata de muitos outros t&oacute;picos a respeito de esta&ccedil;&otilde;es sem disco r&iacute;gido.<br />&Uacute;ltima revis&atilde;o:<br />Revis&atilde;o 4.1.3-en<br />2004-06-20<br />Revisado por: jam<br /><br />Sum&aacute;rio<br />Introdu&ccedil;&atilde;o<br />&nbsp;1.. Disclaimer<br />&nbsp;1.. Copyright e Licen&ccedil;a<br />&nbsp;Cap&iacute;tulo 1. A Teoria da Opera&ccedil;&atilde;o<br />&nbsp;#.1. Os passos que as esta&ccedil;&otilde;es de trabalho (clientes) seguir&atilde;o<br />1.2. Rodando o kernel de dentro da mem&oacute;ria<br />1.2.1 Boot ROM<br />1.2.2 M&iacute;dia local<br />Cap&iacute;tulo 2. Instalando o LTSP no servidor<br />2.1. Instalando os utilit&aacute;rios do LTSP<br />2.1.1. Instalando o pacote RPM<br />2.2 Instalando os pacotes TGZ<br />2.2 Instalando os pacotes do cliente LTSP<br />2.3 Configurando os servi&ccedil;os necess&aacute;rios para o LTSP<br />2.4. Configura&ccedil;&atilde;o espec&iacute;fica da esta&ccedil;&atilde;o de trabalho<br />2.5. Visualizando as configura&ccedil;&otilde;es atuais<br />Cap&iacute;tulo 3. Configurando a esta&ccedil;&atilde;o de trabalho (o cliente)<br />3.1. Dando o boot com PXE<br />3.2. Dando o boot com Etherboot<br />Cap&iacute;tulo 4. Rodando as esta&ccedil;&otilde;es de trabalho<br />Cap&iacute;tulo 5. Imprimindo<br />5.1. Configura&ccedil;&atilde;o de cliente<br />5.2. Configura&ccedil;&atilde;o de servidor<br />Cap&iacute;tulo 6. Scripts de tela<br />Cap&iacute;tulo 7. Desproblematizando<br />7.1. Desproblematizando a imagem de disquete Etherboot<br />7.2. Desproblematizando DHCP<br />7.3. Desproblematizando TFTP<br />7.4. Desproblematizando o sistema de arquivos raiz NFS<br />7.5. Desproblematizando o servidor X<br />7.6. Desproblematizando o gerenciador de interface gr&aacute;fica<br />Cap&iacute;tulo 8. Kernels<br />8.1. Padr&otilde;es de kernels LTSP dispon&iacute;veis<br />8.2. Cosntrua o seu pr&oacute;prio kernel<br />Cap&iacute;tulo 9. Entradas lts.conf<br />9.1. Exemplo de arquivo lts.conf<br />9.2. Par&acirc;metros lts.conf dispon&iacute;veis<br />Cap&iacute;tulo 10. Applicativos locais<br />10.1. Vantagens de se rodar aplicativos localmente<br />10.2. Considera&ccedil;&otilde;es ao configurar suporte &agrave; aplicativos locais<br />10.3. Configura&ccedil;&atilde;o de servidor para aplicativos locais<br />10.4. Configura&ccedil;&atilde;o de aplicativos<br />10.5. Ativando aplicativos locais<br />Cap&iacute;tulo 11. Exemplos de configura&ccedil;&atilde;o<br />11.1. Mouse serial<br />11.2. Mouse PS/2<br />11.3. Impressora USB em um ThinkNic<br />11.4. For&ccedil;ando uma esta&ccedil;&atilde;o de trabalho a rodar o servidor X XFree86 3.3.6<br />Cap&iacute;tulo 12. Outras fontes de informa&ccedil;&atilde;o<br />12.1. Refer&ecirc;ncias online<br />12.2. Publica&ccedil;&otilde;es Impressas<br /><br />Introdu&ccedil;&atilde;o<br />O que &eacute; LTSP?<br />LTSP (Linux Terminal Server Project) &eacute; um conjunto de solu&ccedil;&otilde;es que oferece servi&ccedil;os para clientes sem disco r&iacute;gido em suas m&aacute;quinas. Ele disp&otilde;e de um meio simples para utilizar esta&ccedil;&otilde;es de trabalho tanto no modo gr&aacute;fico quanto no modo texto.<br />Os criadores do LTSP acham sem sentido ter computadores desktops completos. Por isso desenvolveram uma solu&ccedil;&atilde;o (composta por um conjunto de outras) que assiste a clientes variados - assim como n&atilde;o exige que estes sejam m&aacute;quinas com alto poder de processamento. A utiliza&ccedil;&atilde;o de computadores-sucatas (DX4, pentium, pentium MMX, celeron, k-5, k-6, etc. numa frequ&ecirc;ncia entre 66 e 300 MHz) nos clientes &eacute; vi&aacute;vel. Utiliza-se a placa de rede para o boot, o que dispensa disco r&iacute;gidos, disquetes, CD-ROM&acute;s, etc. - apesar de suas exclus&otilde;es n&atilde;o serem necess&aacute;rias.<br />Durante o boot, os clientes obt&ecirc;m seus endere&ccedil;os de IP e kernel do servidor e depois o sistema de arquivo &eacute; montado via NFS, tamb&eacute;m atrav&eacute;s do servidor.<br />H&aacute; tr&ecirc;s possibilidades de configura&ccedil;&atilde;o do LTSP:<br />Interface Gr&aacute;fica com o X Window System Pode-se acessar qualquer aplica&ccedil;&atilde;o no servidor, ou em outros servidores que estejam na rede, atrav&eacute;s do X Window.<br />Modo caracter baseado em sess&otilde;es Telnet<br />O cliente pode solicitar m&uacute;ltiplas sess&otilde;es Telnet ao servidor. Estas sess&otilde;es s&atilde;o alternadas atrav&eacute;s das teclas Alt+F1 at&eacute; Alt+F9.<br />Shell prompt<br />A esta&ccedil;&atilde;o de trabalho pode ser configurada para ir direto pro console.<br />O interessante do LTSP &eacute; que voc&ecirc; pode ter v&aacute;rios clientes em apenas um servidor Linux. A quantidade de clientes vai depender do n&uacute;mero de servidores e das aplica&ccedil;&otilde;es que ser&atilde;o usadas.<br />1. Disclaimer<br />Nem o autor nem os distribuidores, ou algum contribuinte tem nunhuma tipo de responsabilidade por danos f&iacute;sicos, financeiros, ou morais ou qualquer outro tipo dos danos ocorridos seguindo as sugest&otilde;es neste texto.<br />2. Copyright e Licen&ccedil;a<br />Este documento possui o copyright 2004 por James McQuillan, e &eacute; liberado sob os termos da licen&ccedil;a GNU Free Documentation License, que &eacute; portanto incorporado como refer&ecirc;ncia.<br /><br />Cap&iacute;tulo 1. A Teoria da Opera&ccedil;&atilde;o<br />H&aacute; v&aacute;rios passos que envolvem a inicializa&ccedil;&atilde;o dos clientes. Entendendo o que acontece fica mais f&aacute;cil resolver os problemas.<br /><br />S&atilde;o quatro servi&ccedil;os b&aacute;sicos que o LTSP usa:<br />&nbsp;DHCP<br />&nbsp;TFTP<br />&nbsp;NFS<br />&nbsp;XDMCP<br /><br />Como o LTSP &eacute; muito flex&iacute;vel voc&ecirc; pode rodar estes servi&ccedil;os de diferentes servidores ou at&eacute; mesmo todos num s&oacute;. Imaginemos apenas um servidor. S&atilde;o estas as etapas percorridas pelos clientes:<br /><br />1.1. Os passos que as esta&ccedil;&otilde;es de trabalho (clientes) seguir&atilde;o<br />1. Carregar o kernel do Linux na mem&oacute;ria do cliente. Pode ser feito de v&aacute;rias formas, inclusive:<br />Bootrom (Etherboot, PXE, MBA, Netboot)<br />Disquete<br />Disco r&iacute;gido<br />CD-ROM<br />Cart&atilde;o de mem&oacute;ria via USB<br />Cada um desses m&eacute;todos ser&aacute; explicado posteriormente nesse cap&iacute;tulo.<br />2. Ap&oacute;s carregar o kernel ele come&ccedil;ar&aacute; sua execu&ccedil;&atilde;o.<br />3. O kernel inicializar&aacute; o sistema inteiro e todos os perif&eacute;ricos que ele reconhecer.<br />4. Durante o processo de carregamento do kernel, ser&aacute; rodado um disco virtual (ramdisk) tamb&eacute;m na mem&oacute;ria. Este disco virtual ser&aacute; montado como o diret&oacute;rio raiz &quot;/&quot; atrav&eacute;s da linha de comamdo root=/dev/ram0 do kernel.<br />5. Quando o kernel de inicializa&ccedil;&atilde;o terminar, ser&aacute; rodado o programa init. No LTSP, o kernel foi instru&iacute;do para ler um pequeno script do shell. Para isso foi passado init=/linuxrc na linha de comando do kernel.<br />6. O script /linuxrc come&ccedil;a a fazer uma verredura do PCI bus procurando pela placa de rede. Para cada dispositivo PCI que ele encontrar, ele verifica no arquivo /etc/niclist para checar a sua ocorr&ecirc;ncia neste. Quando encontrado, o nome do m&oacute;dulo de driver NIC &eacute; retornado e o m&oacute;dulo do kernel &eacute; lido. J&aacute; nas placas ISA, o m&oacute;dulo do driver PRECISA ser especificado na linha de comando do kernel assim com os par&acirc;metros de endere&ccedil;o ou IRQ que poder&atilde;o ser necess&aacute;rios.<br />7. Um pequeno cliente de DHCP chamado dhclient ser&aacute; rodado e far&aacute; outra requisi&ccedil;&atilde;o do servidor DHCP. Esta requisi&ccedil;&atilde;o foi feita separadamente porque eram necess&aacute;rias mais informa&ccedil;&otilde;es do que as recebidas do bootrom, com a primeira requisi&ccedil;&atilde;o do servidor DHCP.<br />8. Quando o dhclient tiver uma resposta do servidor, ser&aacute; rodado o arquivo /etc/dhclient-script que pegar&aacute; as informa&ccedil;&otilde;es recebidas pelo dhclient e confgurar&aacute; a interface eth0.<br />9. At&eacute; aqui, o sistema de arquivo raiz tem um disco virtual. Agora o script /linuxrc montar&aacute; um novo sistema de arquivo raiz atrav&eacute;s do NFS. O diret&oacute;rio que &eacute; exportado do servidor &eacute; o /opt/ltsp/i386. N&atilde;o pode-se simplesmente montar como &quot;/&quot;. Primeiro tem que ser montado como /mnt. Depois ele far&aacute; um pivot_root que trocar&aacute; o atual sistema de arquivo raiz por um novo sistema de arquivo. Quando ele terminar, o sistema de arquivo NFS ser&aacute; montado na raiz &quot;/&quot; e o antigo sistema de arquivo raiz ser&aacute; montado em /oldroot.<br />10. Quando a montagem e a pivotagem do novo sistema de arquivos estiverem conclu&iacute;das, o trabalho do /linuxrc estar&aacute; feito e precisaremos solicitar o programa /sbin/init.<br />11. O init ler&aacute; o arquivo /etc/inittab e com&ccedil;ar&aacute; a configurar o ambiente da esta&ccedil;&atilde;o de trablho (cliente).<br />12. Uma das primeiras coisas que o arquivo inittab faz &eacute; ler o comando rc.sysinit que rodar&aacute; enquanto o cliente estiver no estado &quot;sysinit&quot;.<br />13. O script rc.sysinit criar&aacute; 1MB de disco virtual para conter tudo que precisar&aacute; ser escrito (ou modificado).<br />14. O disco virtual ser&aacute; montado como o diret&oacute;rio /tmp. Quaisquer arquivos que precisar serem escritos ir&atilde;o realmente existir no diret&oacute;rio /tmp e ter&atilde;o links simb&oacute;licos (symbolic links) apontando para eles.<br />15. O sistema de arquivo /proc &eacute; montado.<br />16. O arquivo lts.conf ser&aacute; analisado (parsed) e todos os par&acirc;metros nesse arquivo que perten&ccedil;am &agrave; essa esta&ccedil;&atilde;o de trabalho ser&atilde;o configurados com vari&aacute;veis do ambiente para o script rc.sysinit usar.<br />17. Se a esta&ccedil;&atilde;o de trabalho for configurada para fazer swap (swap over) no NFS, o diret&oacute;rio /var/opt/ltsp/swapfiles ser&aacute; montado como /tmp/swapfiles. Mas se n&atilde;o tiver um arquivo de troca (swapfile) para essa esta&ccedil;&atilde;o de trabalho ainda, ser&aacute; criado automaticamente. O tamanho dos swapfiles &eacute; configurado no arquivo lts.conf.<br />O swapfile ser&aacute; ativado usando o comando swapon.<br />18. A interface de rede loopback &eacute; configurada. Essa &eacute; a interface de rede que tem o endere&ccedil;o de IP 127.0.0.1.<br />19. Se aplica&ccedil;&otilde;es locais est&atilde;o ativadas, o diret&oacute;rio /home ser&aacute; montado para que as aplica&ccedil;&otilde;es tenham acesso ao /home dos usu&aacute;rios.<br />20. Muitos diret&oacute;rios s&atilde;o criados no arquivo de sistema /tmp para segurar alguns arquivos de tr&acirc;nsito que s&atilde;o necess&aacute;rios enquanto o sistema est&aacute; rodadno. Os diret&oacute;rios abaixo ser&atilde;o criados.<br />a. /tmp/compiled<br />b. /tmp/var<br />c. /tmp/var/run<br />d. /tmp/var/log<br />e. /tmp/var/lock<br />f. /tmp/var/lock/subsys<br />21. O arquivo /tmp/syslog.conf ser&aacute; criado. Esse arquivo conter&aacute; informa&ccedil;&otilde;es sobre o deamon syslogd que se hospedar&aacute; na rede para enviar a informa&ccedil;&atilde;o de login. O host syslog est&aacute; especificado no arquivo lts.conf. H&aacute; um link chamado /etc/syslog.conf qua aponta para o arquivo /tmp/syslog.conf.<br />Original do item 21: &quot; The /tmp/syslog.conf file will be created. This file will contain information telling the syslogd daemon which host on the network to send the logging information to. The syslog host is specified in the lts.conf file. There is a symbolic link called /etc/syslog.conf that points to the /tmp/syslog.conf file.&quot;<br />22. O deamon syslogd &eacute; iniciado usando o arquivo de configura&ccedil;&atilde;o criado no item 21.<br />23. Uma vez que o script rc.sysinit &eacute; rodado, &eacute; retornado ao programa /sbin/init que mudar&aacute; o runlevel do sysinit para 5.<br />24. Por default, h&aacute; no inittab chamadas para rodar o script /etc/screen_session em tty1, tty2 e tty3. Isso significa que pode-se rodar tr&ecirc;s sess&otilde;es ao mesmo tempo e que o tipo das sess&otilde;es &eacute; controlado pelas chamadas de SCREEN_01, SCREEN_02 and SCREEN_03 no lts.conf.<br />Original do item 24: A palavra &quot;entries&quot; foi traduzida como &quot;chamadas&quot;.<br />25. Se o SCREEN_01 est&aacute; configurado como startx, o script /etc/screen.d/startx ser&aacute; executado. Ele rodar&aacute; o X Window Sysytem oferecendo-lhe uma interface gr&aacute;fica.<br />No arquivo lts.conf, tem um par&acirc;metro chamado XSERVER. Se estiver faltando este par&acirc;metro ou come&ccedil;ar&atilde;o esiver &quot;auto&quot; em seu lugar, ocorrer&aacute; uma tentativa de detec&ccedil;&atilde;o autom&aacute;tica da placa de v&iacute;deo.Se a placa for PCI ou AGP, ele pegar&aacute; o fabricante e o seu identificador dela (Vendor and Device id) e procurar&aacute; no arquivo /etc/vidlist.<br />Se Xorg 6.7 assistir a placa, a rotina pci_scan retornar&aacute; o m&oacute;dulo do seu driver. Se ela for assitida apenas pelo XFree86 3.3.6, pci_scan retornar&aacute; o nome do servidor X a ser usado. O script startx<br />Original do item 25: A palavra &quot;suported&quot; foi traduzida como asistir e &quot;driver module&quot; como &quot;m&oacute;dulo de driver&quot;.<br />26. Se o Xorg for usado, o script /etc/build_x4_cfg ser&aacute; chamado para criar um arquivo XF86Config. Se o XFree86 3.3.6 for usado, ent&atilde;o o script ser&aacute; chamado para criar o arquivo XF86Config. Estes arquivos s&atilde;o colocados no diret&oacute;rio /tmp que, se voc&ecirc; se lembrar, &eacute; um disco virtual visto apenas pela esta&ccedil;&atilde;o de trabalho.<br />O arquivo XF86Config ser&aacute; criado baseado nas chamadas do arquivo /etc/lts.conf.<br />27. Uma vez criado o arquivo XF86Config ent&atilde;o o script startx rodar&aacute; o servidor do X como este novo arquivo de confugura&ccedil;&atilde;o.<br />28. O servidor do X enviar&aacute; uma requisi&ccedil;&atilde;o XDMCP ao servidor LTSP, que oferecer&aacute; uma tela de login (login dialog).<br />29. Agora, o usu&aacute;rio poder&aacute; logar. Eles pegar&atilde;o uma sess&atilde;o do servidor.<br />Isso confunde muitas pessoas no come&ccedil;o. Eles est&atilde;o numa esta&ccedil;&atilde;o de trabalho, mas rodando uma sess&atilde;o no servidor. Todos os comandos que eles rodarem ser&atilde;o rodados no servidor, mas a sa&iacute;da ser&aacute; mostrada na sua esta&ccedil;&atilde;o de trabalho.<br /><br />1.2. Rodando o kernel de dentro da mem&oacute;ria<br />Para rodar o kernel do Linux nas mem&oacute;rias das esta&ccedil;&otilde;es de trabalho existem v&aacute;rios meios.<br />Boot ROM<br />M&iacute;dia local<br /><br />1.2.1 Boot ROM<br />Etherboot<br />Etherboot &eacute; um projeto bootrom muito popular de c&oacute;digo aberto. Ele cont&eacute;m drivers de muitas placas de rede e trabalha muito bem com o LTSP.<br />O kernel do Linux tem que ser marcado (tagged) com o mknbi-linux, que ir&aacute; preparar o kernel para o boot em rede colocando no kernel alguns c&oacute;digos adicionais e adicionando o initrd para o fim do kernel.<br />Os kernels que j&aacute; foram fornecidos pelo LTSP s&atilde;o marcados e est&atilde;o prontos para dar o boot pelo Etherboot.<br />Etherboot tamb&eacute;m pode ser escrito num disquete, que &eacute; ideal para testes.<br />PXE<br />Parte da especifica&ccedil;&atilde;o do &quot;Wired for Management&quot;, que vem tardiamente das anos 90, incluiu uma espeficica&ccedil;&atilde;o para a tecnologia de bootrom conhecida como o Pre-boot Execution Environment abreviada como PXE.<br />Um bootrom PXE pode rodar, em sua maioria, um arquivo de 32 Kbytes. Um kernel do Linux &eacute; maior, ent&atilde;o n&oacute;s configuramos o PXE para ler um 2o. est&aacute;gio do boot-loader (a 2nd stage boot-loader) chamado pxelinux. Ele &eacute; pequeno suficiente para ser carregado e ele sabe como rodar muitos arquivos grandes, como o kernel do Linux.<br />MBA<br />MBA (Managed Boot Agent) &eacute; um bootrom de uma empresa chamada emBoot. Ela foi uma divis&atilde;o da 3Com. MBA &eacute; realmente 4 boots em 1. Ele abrigar&aacute; PXE, TCP/IP, RPL e Netware.<br />A implementa&ccedil;&atilde;o de PXE trabalha bem. Voc&ecirc; pode us&aacute;-la com pxelinux para dar boot em um kernel Linux.<br />O m&eacute;todo TCP/IP pode ser usado, mas o kernel primeiro precisa estar preparado com um utilit&aacute;rio chamado imggen.<br />Netboot<br />O Netboot, assim como o Etherboot, &eacute; um sotware livre que oferece gratuitamente imagens de boot ROM. A diferen&ccedil;a &eacute; que ele &eacute; um evolt&oacute;rio em torno do driver NDIS ou pacotes de drivers que enviam com as placas de rede.<br />Orignal do Par&aacute;grafo acima: &quot; Netboot, like Etherboot, is a free software project that provides free boot ROM images. The difference is that it is a wrapper around the NDIS driver or packet drivers that ship with the network cards.&quot;<br /><br />1.2.2 M&iacute;dia local<br />Disquete<br />H&aacute; duas maneiras de boot para uma esta&ccedil;&atilde;o de trabalho LTSP. Uma &eacute; carregar o Etherboot no setor do disquete. Ent&atilde;o, ele agir&aacute; simplesmente como um bootrom. O c&oacute;digo do boot ser&aacute; excutado, aplaca de rede ser&aacute; inicializada e o kernel ser&aacute; carregado do servidor.<br />Voc&ecirc; tamb&eacute;m pode gravar o kernel e o initrd em um disquete e dar o boot. Entetanto, &eacute; realmente mais r&aacute;pido carregar o kernel pela rede.<br />Disco R&iacute;gido (HD)<br />O disco r&iacute;gido pode ser usado com o LILO ou GRUB para carregar o kernel do Linux e o initrd. Ou, voc&ecirc; pode ler uma imagem Etherboot bootrom do HD e ele agir&aacute; como um bootrom.<br />CD-ROM<br />Um CD-ROM boot&aacute;vel pode ser carregado com um Linux kernel ou uma imagem Etherboot.<br />Dispositivo de Mem&oacute;ria USB (Memory Keys)<br />Assim como um CD-ROM, disquete e HD, voc&ecirc; pode usar um dispositivo de mem&oacute;ria USB para dar o boot tanto um m&oacute;dulo Eherboot ou um completo kernel do Linux e a imagem initrd.<br /><br />Cap&iacute;tulo 2. Instalando o LTSP no servidor<br />&Eacute; melhor pensar no LTSP como uma completa distribui&ccedil;&atilde;o Linux. &Eacute; uma distribui&ccedil;&atilde;o que est&aacute; em cima de uma distribui&ccedil;&atilde;o do servidor. Esta pode ser qualquer distribui&ccedil;&atilde;o Linux que voc&ecirc; desejar. Na verdade, n&atilde;o precisa ter necessariamente o Linux no servidor. O &uacute;nico pr&eacute;-requisito &eacute; que o sistema operacional do servidor suporte o NFS (Network File System). A maioria dos sistemas UNIX suportam o NFS.<br />H&aacute; tr&ecirc;s etapas para criar um servido LTSP:<br />Instala&ccedil;&atilde;o dos utilit&aacute;rios do LTSP<br />Instala&ccedil;&atilde;o dos pacotes dos clientes<br />Configura&ccedil;&atilde;o dos servi&ccedil;os necess&aacute;rios para o LTSP<br /><br />2.1. Instalando os utilit&aacute;rios do LTSP<br />A vers&atilde;o 4.1 do LTSP tem um pacote de utilit&aacute;rios para a instala&ccedil;&atilde;o e gerenciamento dos pacotes dos clientes (as coisas que ser&atilde;o executadas nos clientes), e para a configura&ccedil;&atilde;o dos servi&ccedil;os no servidor LTSP.<br />O utilit&aacute;rio de administra&ccedil;&atilde;o &eacute; o ltspadmin e o das ferramentas de configura&ccedil;&atilde;o &eacute; ltspcfg. Ambos os utilit&aacute;rios fazem parte do pacote ltsp-utils.<br />O pacote ltsp-utils est&aacute; dispon&iacute;vel nos formatos RPM e TGZ. Escolha qual formato vco&ecirc; prefere e siga as intru&ccedil;&otilde;es adequadas.<br /><br />2.1.1. Instalando o pacote RPM<br />Baixe o pacote mais recente do ltsp-utils em RPM e instale-o usando o comando abaixo:<br />&nbsp;rpm -ivh ltsp-utils-0.1-0.noarch.rpm<br /><br />O comando acima instalar&aacute; os utilit&aacute;rios no servidor.<br /><br />2.2 Instalando os pacotes TGZ<br />Baixe o pacote mais recente do ltsp-utils em TGZ e instale-o usando o comando abaixo:<br />&nbsp;tar xzf ltsp-utils-0.1-0.noarch.tgz<br />&nbsp;cd ltsp_utils<br />&nbsp;./install.sh<br />&nbsp;cd ..<br /><br />O comando acima instalar&aacute; os utilit&aacute;rios no servidor. Ele &eacute; usado para sistemas que n&atilde;o se baseiam no pacote RPM.<br /><br />2.2 Instalando os pacotes do cliente LTSP<br />Ap&oacute;s instalar a o ltsp-utils, voc&ecirc; j&aacute; pode rodar o comando ltspadmin. Este utilit&aacute;rio &eacute; usado para o gerenciamento dos pacotes dos clientes LTSP. Ele requisitar&aacute; um download e pegar&aacute; uma lista dos pacotes atuais.<br />Origninal: &quot; Once the installation of the ltsp-utils package is complete, you can run the ltspadmin command. This utility is used to manage the LTSP Client packages. It will query the LTSP download repository, and get the list of currently available packages.&quot;<br />Execute o comando ltspadmin e voc&ecirc; ver&aacute; uma tela como esta:<br />&nbsp;Figura 2-1. Instalador LTSP &ndash; Tela principal<br />Voc&ecirc; poder&aacute; escolher a op&ccedil;&atilde;o &quot;Install/Update&quot;, e se for a primeira vez que voc&ecirc; estiver rodando o programa, ele mostrar&aacute; uma tela de configura&ccedil;&atilde;o do instalador.<br />Figura 2-2. Instalador LTSP installer &ndash; Tela de configura&ccedil;&atilde;o<br />Nesta tela voc&ecirc; pode configurar muitas coisas que o instalador usar&aacute; para baixar e instalar os pacotes do LTSP. Aqui est&atilde;o:<br />Where to retrieve packages from (De onde voc&ecirc; quer obter os pacotes)<br />Isto &eacute; uma URL apontando para onde o pacote est&aacute;. Por default, ele ser&aacute; <a href="http://www.ltsp.org/ltsp-4.1" title="http://www.ltsp.org/ltsp-4.1" rel="nofollow">http://www.ltsp.org/ltsp-4.1</a>, mas voc&ecirc; pode instal&aacute;-lo a partir de um sistema de arquivo local - voc&ecirc; usa o arquivo inv&eacute;s da URL. Pro exemplo, se os pacotes estiverem num CD-ROM e ele estiver montado em /mnt/cdrom, ent&atilde;o o valor ser&aacute;: <a href="///mnt/cdrom" title="///mnt/cdrom" rel="nofollow">file:///mnt/cdrom</a>. (Aten&ccedil;&atilde;o com os 3 par&ecirc;nteses).<br />In which directory would you like to place the LTSP client tree (Em qual diret&oacute;rio voc&ecirc; gostaria de colocar a &aacute;rvore cliente LTSP)<br />Ele &eacute; o diret&oacute;rio no servidor onde voc&ecirc; gostaria de colocar a &aacute;rvore do cliente. Ele ser&aacute; /opt/ltsp. O diret&oacute;rio ser&aacute; criado caso ele n&atilde;o exista.<br />Dentro desse diret&oacute;rio, os diret&oacute;rios root para cada arquitetura ser&atilde;o criados. Atualmente, apenas as esta&ccedil;&otilde;es x86 s&atilde;o suportadas pelo LTSP, mas h&aacute; muitas pessoas trabalhando para suportar outras arquiteturas como PPC e Sparc.<br />HTTP Proxy (Proxy de HTTP)<br />Se o servidor estiver atr&aacute;s de um firewall, e todos os acessos &agrave; web precisarem passar pelo proxy, voc&ecirc; pode configurar o instalador para usar o proxy aqui. O valor dever&aacute; conter a URL para o proxy, incluindo o protocolo e a porta. Um exemplo para essa configura&ccedil;&atilde;o &eacute;: <a href="http://firewall.yourdomain.com:3128/" title="http://firewall.yourdomain.com:3128" rel="nofollow">http://firewall.yourdomain.com:3128</a>.<br />Se voc&ecirc; n&atilde;o precisa de um proxy, coloque &quot;none&quot;.<br />FTP Proxy (Proxy de FTP)<br />Para os pacotes localizados num servidor FTP, se voc&ecirc; precisar passar atrav&eacute;s de um FTP proxy, voc&ecirc; coloca-o aqui. A sintaxe &eacute; parecida &agrave; op&ccedil;&atilde;o acima do HTTP Proxy.<br />Se voc&ecirc; n&atilde;o precisa de um proxy, coloque &quot;none&quot;.<br />Ap&oacute;s passar pela tela de configura&ccedil;&atilde;o, o instalador requisitar&aacute; os pacotes e obt&eacute;m a lista de componentes deispon&iacute;veis atualmente.<br />Figura 2-3. Instalador LTSP &ndash; Lista de componentes<br />Selecione cada componente que voc&ecirc; quer instalar. Para selecion&aacute;-los, mova a linha branca para aquele componente e clique 'I ' para selecion&aacute;-lo. Voc&ecirc; tamb&eacute;m pode clicar em ' A' para selecionar TODOS os componentes. A maior parte do tempo, isso vai ser o que voc&ecirc; quer. Dessa forma, voc&ecirc; suportar&aacute; uma grande linha de hardrware de clientes leves.<br />Existem v&aacute;rias teclas de navega&ccedil;&atilde;o nesta tela. Voc&ecirc; pode obter ajuda sobre estas pressionando a tecla 'H'.<br /><br />Figura 2-4. Instalador LTSP &ndash; Janela de ajuda<br />Se voc&ecirc; quiser olhar a lista dos pacotes que est&atilde;o num componente particular, pressione 'S' e a lista dos pacotes ser&aacute; exibida. Ele mostrar&aacute; a vers&atilde;o atual instalada e tamb&eacute;m a &uacute;ltima vers&atilde;o dispon&iacute;vel.<br /><br />Figura 2-5. Instalador LTSP &ndash; Lista de pacotes<br />Uma vez que os componentes forem selecinados, voc&ecirc; pode sair da tela de sele&ccedil;&atilde;o dos componentes. O instalador lhe perguntar&aacute; se voc&ecirc; realmente quer instalar/atualizar os pacotes selecinados. Se voc&ecirc; responder 'Y', ele baixar&aacute; e instalar&aacute; os pacotes selecionados.<br /><br />&nbsp;2.3 Configurando os servi&ccedil;os necess&aacute;rios para o LTSP<br />S&atilde;o quatro os servi&ccedil;os b&aacute;sicos necess&aacute;rios para assistir o boot de uma esta&ccedil;&atilde;o LTSP. Eles s&atilde;o:<br />&nbsp;DHCP<br />&nbsp;TFTP<br />&nbsp;NFS<br />&nbsp;XDMCP<br /><br />O ltspcfg pode ser usado para configurar todos esses servi&ccedil;os e mais muitas outras coisas relacionadas ao LTSP.<br />Voc&ecirc; pode acessar o ltspcfg atrav&eacute; do ltspadmin ou rodar o ltspcfg diretamente digitando-o na linha de comando. Voc&ecirc; ver&aacute; uma tela como essa:<br />Figura 2-6. ltspcfg &ndash; Tela inicial<br />Ela mostra todas as coisas que o utilit&aacute;rio procura.<br />Para configurar todas as coisas que precisam ser configuradas, escolha 'C' e o menu de configura&ccedil;&atilde;o ser&aacute; exibido. No menu de configura&ccedil;&atilde;o, voc&ecirc; precisar&aacute; navegar em cada item, para ter certeza que ele est&aacute; configurdo corretamente para servir as est&ccedil;&atilde;os de trabalho do LTSP.<br />Figure 2-7. ltspcfg &ndash; Tela inicial<br />1 - Runlevel<br />O Runlevel &eacute; a vari&aacute;vel usada pelo programa init. Em sistemas Linux e UNIX, sem nenhum tempo dado, &eacute; dito ao sistema para ele ficar num &quot;Runlevel&quot; espec&iacute;fico. O Runlevel 2 ou 3 &eacute; tipicamente usado quando o servidor est&aacute; em modo texto. O Runlevel 5 tipicamente indica que o sistema est&aacute; no modo gr&aacute;fico numa rede.<br />Para um servidor LTSP, o Runlevel 5 &eacute; tradicionalmente usado. A maioria dos sistemas j&aacute; s&atilde;o configurados para servir NFS e XDMCP no Runlevel 5. Para aqueles sistemas que n&atilde;o est&atilde;o configurados para isto, o utilit&aacute;rio tomar&aacute; conta deles.<br />2 - Interface selection<br />Para sistemas que t&ecirc;m v&aacute;rias interfaces de rede, voc&ecirc; precisar&aacute; selecionar em qual interface de rede os cliente est&atilde;o conectados.<br />Selecionando a interface, a ferramenta de configura&ccedil;&atilde;o estar&aacute; apta a criar os arquivos de configura&ccedil;&atilde;o corretamente, assim como os arquivos dhcpd.conf e /etc/hosts.<br />3 - DHCP configuration<br />O DHCP precisa ser configurado para fornecer os campos requisitados peos clientes. Entre estes campos, est&atilde;o fixed-address (Mac Address) , filename, subnet-mask, broadcast-address e root-path.<br />Selecionadno este item do menu, voc&ecirc; estar&aacute; apto a criar o arquivo de configura&ccedil;&atilde;o dhcpd.conf e habilitar o dhcpd para rodar automaticamente quando sua m&aacute;quina for iniciada.<br />4 - TFTP configuration<br />O TFTP &eacute; usado pelos clientes para baixarem o kernel do Linux. O tftpd precisa estar rodando no servidor para servir o kernel.<br />5 - Portmapper configuration<br />O Portmapper &eacute; usado pelos servi&ccedil;os RPC. Cada servi&ccedil;o RPC, assim como o NFS.<br />6 - NFS configuration<br />NFS &eacute; o servi&ccedil;o que permite as &aacute;rvores do diret&oacute;rio local serem montadas por m&aacute;quinas remotas. Ele &eacute; necess&aacute;rio para o LTSP porque os clientes montam seus sistemas ra&iacute;zes (root) atrav&eacute;s do servidor.<br />Este item cuidar&aacute; para que o NFS rode ap&oacute;s o boot. O arquivo de configura&ccedil;&atilde;o &eacute; o /etc/exports e a sua cria&ccedil;&atilde;o &eacute; descrita depois nesta se&ccedil;&atilde;o.<br />7 - XDMCP configuration<br />XDMCP &eacute; o &quot;X Display Manager Control Protocol&quot;. O servidor X envia uma requisi&ccedil;&atilde;o ao gerenciador de interfaces gr&aacute;ficas no servidor para conseguirem um tela de login.<br />Os gerenciadores de interfaces gr&aacute;ficas mais populares s&atilde;o XDM, GDM e KDM. Este item mostrar&aacute; quais gerenciadores de interfaces gr&aacute;ficas foram encontrados e qual foi configurado para rodar.<br />Por quest&otilde;es de seguran&ccedil;a, o gerenciador de interfaces gr&aacute;ficas &eacute; configurado por defualt para n&atilde;o permirtir acesso remoto. Esta &eacute; geralmente a raz&atilde;o para a tela cinza com cursor X grande. ltspcfg pode geeralmente configurar o gerenciador de interfaces gr&aacute;ficas para permitir acesso remoto para os clientes conseguirem conex&atilde;o.<br />8 - Create /etc/hosts entries<br />Muitos servi&ccedil;os, como NFS e o gerenciador de interfaces gr&aacute;ficas precisam estar aptos a vincular o endere&ccedil;o IP de um cliente ao seu nome. Voc&ecirc; pode configurar o Berkeley Internet Naming Daemon (BIND) para fazer isto, mas voc&ecirc; deve ter certeza que configurou reversamente correto. Finalmente, usando bind &eacute; provalvelmente a melhor forma para fazer isto, mas a configura&ccedil;&atilde;o do bind foge do escopo deste documento e do utilit&aacute;rio ltspcfg.<br />Do original do par&aacute;grafo acima: &quot; Many services, like NFS and the Display manager need to be able to map the IP address of the workstation to a hostname. You could setup the Berkeley Intenet Naming Daemon (BIND) to do that, but you'd have to make sure you get the reverses setup properly. Ultimately, using bind is probably the best way to do it, but configuration of bind is beyond the scope of this document and the ltspcfg utility.&quot;<br />9 - Create /etc/hosts.allow entries<br />Alguns servi&ccedil;os usam uma camada de seguran&ccedil;a conhecida como tcpwrappers. Isto &eacute; configurado atrav&eacute;s do arquivo /etc/hosts.allow. Este item configurar&aacute; esse arquivo para voc&ecirc;.<br />10 - Create the /etc/exports file<br />Este &eacute; o arquivo que o NFS usa para determinar quais diret&oacute;rios s&atilde;o permitidos serem montados por m&aacute;quinas remotas. Este item configurar&aacute; esse arquivo para voc&ecirc;.<br />11 - Create the lts.conf file<br />A configura&ccedil;&atilde;o de cada cliente &eacute; direcionada pelas entradas no arquivo lts.conf. Para significativos clientes com PCI bus, n&atilde;o ser&aacute; necess&aacute;ria entradas adicionais no lts.conf. Mas mesmo assim o arquivo precisa existir. Este item criar&aacute; o arquivo lts.conf default para voc&ecirc;.<br /><br />2.4. Configura&ccedil;&atilde;o espec&iacute;fica da esta&ccedil;&atilde;o de trabalho<br />Agora, est&aacute; na hora de falar sobre os clientes ao servidor LTSP. Existem tr&ecirc;s arquivos que cont&ecirc;em as informa&ccedil;&otilde;es sobre os clientes.<br />1./etc/dhcpd.conf<br />2./etc/hosts<br />3./opt/ltsp/i386/etc/lts.conf<br />2.4.1 /etc/dhcpd.conf<br />Os clientes precisam de um endere&ccedil;o de IP e de outras informa&ccedil;&otilde;es. Eles pegar&atilde;o o seguinte do servidor DHCP:<br />endere&ccedil;o de IP<br />nome do host<br />endere&ccedil;o de IP do servidor<br />gateway default<br />Pathname do kernel para rodar<br />path do servidor e diret&oacute;rio para ser montado como o sistema de arquivos ra&iacute;z<br />Para nosso exemplo de ambiente LTSP, n&oacute;s escolhemos configurar manualmente os endere&ccedil;os de IP das esta&ccedil;&otilde;es de trabalho.<br />Durante o script ltsp_initialize, um arquivo exemplo dhcpd.conf &eacute; instalado. O seu nome &eacute; /etc/dhcpd.conf.example e voc&ecirc; pode copi&aacute;-lo para /etc/dhcpd.conf para faz&ecirc;-lo de base para sua configura&ccedil;&atilde;o do dhcp. Voc&ecirc; precisar&aacute; modificar as partes deste arquivo onde se referem as espeficica&ccedil;&otilde;es dos seus clientes e do servidor.<br />O arquivo /etc/dhcpd.conf.example:<br /><br />&nbsp;default-lease-time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21600;<br />&nbsp;max-lease-time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21600;<br /><br />&nbsp;option subnet-mask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255.255.255.0;<br />&nbsp;option broadcast-address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.0.255;<br />&nbsp;option routers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.0.254;<br />&nbsp;option domain-name-servers&nbsp;&nbsp;&nbsp; 192.168.0.254;<br />&nbsp;option domain-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ltsp.org&quot;;<br />&nbsp;option root-path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;192.168.0.254:/opt/ltsp/i386&quot;;<br /><br />&nbsp;shared-network WORKSTATIONS {<br />&nbsp;&nbsp;&nbsp;&nbsp; subnet 192.168.0.0 netmask 255.255.255.0 {<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;}<br /><br />group&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; use-host-decl-names&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on;<br />&nbsp;&nbsp;&nbsp; option log-servers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.0.254;<br /><br />&nbsp;&nbsp;&nbsp; host ws001 {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hardware ethernet&nbsp;&nbsp;&nbsp;&nbsp; 00:E0:18:E0:04:82;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fixed-address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.0.1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;/lts/vmlinuz.ltsp&quot;;<br />&nbsp;&nbsp;&nbsp; }<br />}<br />Figura 2-8. /etc/dhcpd.conf<br />Como o LTSP vers&atilde;o 2.09pre2, voc&ecirc; n&atilde;o precisa mais especificar um kernel para carregar. O pacote do kernel b&aacute;sico possui todas as placas de redes que o Linux suporta. Existem dois arquivos de kernel inclu&iacute;do no pacote LTSP kernel. Um kernel tem o Linux Progress Patch (LPP) embutido e o outro n&atilde;o. Os nomes dos kernels s&atilde;o:<br />vmlinuz-2.4.9-ltsp-5<br />vmlinuz-2.4.9-ltsp-lpp-5<br /><br />Voc&ecirc; deve ter percebido que o kernel est&aacute; no diret&oacute;rio /tftpboot/lts, mas a entrada para &quot;filename&quot; no arquivo /etc/dhcpd.conf est&aacute; faltando no come&ccedil;o do caminho o diret&oacute;rio /tftpboot. Isso &eacute; porque nas vers&otilde;es 7.1 e posteriores do Redhat, o TFTP roda com a op&ccedil;&atilde;o '-s'. Isso faz com que o daemon tftpd rode no modo secure. Ou seja, ele d&aacute; um chroot para o diret&oacute;rio /tftpboot quando &eacute; iniciado. Consequentemente, todos os arquivos que est&atilde;o dispon&iacute;veis ao daemon tftpd fiquem re&ccedil;acionados ao diret&oacute;rio /tftpboot.<br />Outras distribui&ccedil;&otilde;es Linuxpoder&atilde;o n&atilde;o ter a op&ccedil;&atilde;o '-s' configurada para o tftpd, ent&atilde;o voc&ecirc; precisar&aacute; adicionar o diret&oacute;rio /tftpboot no come&ccedil;o da par&acirc;metro do &quot;filename&quot;.<br /><br />2.4.2. /etc/hosts<br />Mapeia o endere&ccedil;o IP do host ao seu nome.<br />Os computadores geralmente se comunicam bem com o endere&ccedil;o de IP. Ent&atilde;o, n&oacute;s humanos damos nomes aos computadores porque n&atilde;o consigos memorizar tantos n&uacute;meros. &Eacute; a&iacute; que o DNS ou o /etc/hosts entram no jogo. Esta tarefa de mapear geralmente n&atilde;o &eacute; necess&aacute;ria, exceto num ambiente LTSP. Porque sem isso, o NFS dar&aacute; erros de permiss&atilde;o quando os clientes requisitarem a montagem do sistema de arquivo.<br />Al&eacute;m dos problemas do NFS, se os clientes n&atilde;o estiverem listados no arquivo /etc/hosts voc&ecirc; poder&aacute; tamb&eacute;m ter problemas com os gerenciadores de janelas GDM ou KDM.<br />2.4.3. /opt/ltsp/i386/etc/lts.conf<br />H&aacute; entradas de configura&ccedil;&otilde;es que podem ser especificadas no arquivo lts.conf.<br />O arquivo lts.conf tem uma sintaxe simples que conssite em se&ccedil;&otilde;es m&uacute;ltiplas. Tem uma se&ccedil;&atilde;o default chamada [default] e l&aacute; pode ser se&ccedil;&otilde;es para cada cliente separadamente. Os clientes podem ser identificados pelo seu nome, endere&ccedil;o de IP ou MAC address.<br />Um arquivo lts.conf t&iacute;pico se parece com este:<br /><br />&nbsp;1.<br />&nbsp;1. Config file for the Linux Terminal Server Project (<a href="http://www.ltsp.org/" title="www.ltsp.org" rel="nofollow">www.ltsp.org</a>)<br />&nbsp;1.<br /><br />[Default]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 192.168.0.254<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = auto<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_PROTOCOL&nbsp;&nbsp; = &quot;PS/2&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_DEVICE&nbsp;&nbsp;&nbsp;&nbsp; = &quot;/dev/psaux&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_RESOLUTION = 400<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_BUTTONS&nbsp;&nbsp;&nbsp; = 3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USE_XFS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = N<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL_APPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = N<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNLEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 5<br /><br />[ws001]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USE_NFS_SWAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Y<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWAPFILE_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 48m<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNLEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 5<br /><br />[ws002]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = XF86_SVGA<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL_APPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = N<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USE_NFS_SWAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Y<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWAPFILE_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 64m<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNLEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 3<br />Examplo 2-1. Arquivo lts.conf<br />A seguir est&aacute; uma lista destas entradas:<br /><br />XSERVER<br />Se a sua placa de v&iacute;deo &eacute; PCI e se ela for suportada pelo XFree86 4.1, ent&atilde;o voc&ecirc; apenas precisar&aacute; do pacote lts_x_core package. Ele cont&eacute;m todos os m&oacute;dulos de driver para X4.<br />Existem muitos pacotes XFree86 3.3.6 dispon&iacute;veis para o LTSP. Este &eacute; o caso de sua placa de v&iacute;deo n&atilde;o ser suportada pelo XFree86 4.1.<br />Voc&ecirc; criar entradas no arquivo lts.conf para cada cliente separadamente ou voc&ecirc; pode fazer entradas default que s&atilde;o compartilhadas por todos os clientes.<br />Nosso cliente tem um chipset de v&iacute;deo Intel i810 e pode ser detectada automaticamente, ent&atilde;o n&oacute;s n&atilde;o precisamos de nehuma entrada no arquivo lts.conf. A entrada XSERVER pode ser especificada se voc&ecirc; quiser ou pode ser configurada para 'auto' para mostrar que ela ir&aacute; ser detectada automaticamente.<br />RUNLEVEL<br />N&oacute;s queremos rodar o cliente no modo gr&aacute;fico, ent&atilde;o n&oacute;s precisamos configurar o RUNLEVEL para '5'. Isto &eacute; feito com outra entrada no arquivo lts.conf.<br />2.5. Visualizando as configura&ccedil;&otilde;es atuais<br />Com o ltspcfg voc&ecirc; pode dar uma olhada no status atual de todos os servi&ccedil;os necess&aacute;rios para o LTSP. ATrav&eacute;s do menu do ltspcfg, pressione 'S' e voc&ecirc; ver&aacute; o status atual.<br /><br />Figura 2-9. ltspcfg &ndash; Status atual<br /><br />Cap&iacute;tulo 3. Configurando a esta&ccedil;&atilde;o de trabalho (o cliente)<br />Depois que o servidor estiver configurado, est&aacute; na hora de focar a configura&ccedil;&atilde;o no cliente.<br />O projeto LTSP &eacute; todo em cima do que acontece depis que o kernel estiver na mem&oacute;ria. H&aacute; v&aacute;rias de colocar o kernel namem&oacute;ria dos clientes inclusive o Etherboot, Netboot, PXE e disquete.<br /><br />3.1. Inicializando com PXE<br />Se a sua placa de rede ou seu PC tiver PXE embutido, ent&atilde;o voc&ecirc; poder&aacute; us&aacute;-lo para carregar o kernel na mem&oacute;ria. PXE &eacute; uma tecnologia bootrom, parecida com a Etherboot ou Netboot.<br />Voce poder&aacute; precisar ativar o bootrom PXE na sua NIC. Voce poder&aacute; precisar mudar o dispositivo de boot na BIOS da sua paca m&atilde;e, escolhendo a op&ccedil;&atilde;o &quot;Boot from LAN&quot; o primeiro dispositivo a ser o boot, inv&eacute;s do HD ou disquete.<br />PXE tem uma limita&ccedil;&atilde;o de apenas ser capaz de carregar arquivos de no m&aacute;ximo 32kb. Como o kernel do Linux &eacute; um pouco maior, voc&ecirc; n&atilde;o pode carregar o kernel diretamente atrav&eacute;s do PXE. Voc&ecirc; precisar&aacute; careegar algo conhecido como um 'Network Bootstrap Program' ou NBP.<br />Existe um NBP dsipon&iacute;vel para carregar o kernel do Linux pxelinux.0. Ele &eacute; uma parte do pacote syslinux que vem do colaborador do kernel H. Peter Anvin.<br />O pacote do kernel do LTSP inclui o pxelinux.0 NBP e o arquivo de configura&ccedil;&atilde;o necess&aacute;rio para carregar o kernel do Linux e uma imagem inicial do disco virtual (ramdisk).<br />Ele trabalha assim:<br />O bootrom PXE inicializa a placa de rede e envia uma requisi&ccedil;&atilde;o DHCP.<br />O servidor DHCP responde com um endere&ccedil;o de IP e o nome do NBP para carregar.<br />O bootrom PXE baixa o NBP, coloc&aacute;-o na mem&oacute;ria e come&ccedil;a a execut&aacute;-lo.<br />O NBP usa tftp para baixar o arquivo de configura&ccedil;&atilde;o vindo do servidor.<br />O arquivo de configura&ccedil;&atilde;o cont&eacute;m o nome do kernel, o nome do arquivo inicial virtual e op&ccedil;&otilde;es para passar ao kernel, uma vez que ele &eacute; carregado.<br />Abaixo &eacute; exemplo de um arquvo de configura&ccedil;&atilde;o do pxelinux.<br />prompt=0<br />label linux<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kernel bzImage-2.4.24-ltsp-4<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append init=/linuxrc rw root=/dev/ram0 initrd=initrd-2.4.24-ltsp-4.gz<br /><br /><br />O NBP, ent&atilde;o, usa o o tftp para baixar o kernel do Linux e inicializar o disco virtual (initrd).<br />O controle &eacute; passado para o kernel do Linux, ele d&aacute; boot, monta o initrd e continua com a iniciliza&ccedil;&atilde;o do cliente.<br /><br />3.2. Dando o boot com Etherboot<br /><br /><br />Etherboot &eacute; um pacote de programas para a cria&ccedil;&atilde;o de imagens ROM que podem baixar c&oacute;digo atrav&eacute;s de uma rede Ethernet para ser executado em um computador x86. Muitos adaptadoes de rede possuem um compartimento onde um chip ROM pode ser instalado. Etherboot &eacute; c&oacute;digo que pode ser colocado nesta ROM.<br /><br />-- Ken Yap<br /><br />Etherboot tamb&eacute;m &eacute; um software livre, protegido atrav&eacute;s da licen&ccedil;a GNU General Public License, Vers&atilde;o 2 (GPL2).<br />Para usar Etherboot, caso voc&ecirc; tenha uma placa de rede com um bootrom Etherboot, voc&ecirc; talvez tenha que mudar a configura&ccedil;&atilde;o de sua BIOS para faz&ecirc;-la &quot;Bootar da LAN&quot; antes de inicializar de um disquete ou disco r&iacute;gido.<br />Se voc&ecirc; ainda n&atilde;o tem um bootrom Etherboot, voc&ecirc; pode fazer um bootrom, ou fazer um disquete com uma imagem Etherboot image em sua se&ccedil;&atilde;o de boot.<br />Etherboot suporta in&uacute;meras placas de rede. Mais de 200 modelos, com ainda mais modelo0s sendo adiionados a cada dia. Caso voc&ecirc; deseje fazer um disquete ou gravar o c&oacute;digo em uma Eprom, voc&ecirc; ter&aacute; que determinar que modelo de placa de rede voc&ecirc; possui.<br /><br />3.2.1. Escolhendo um driver Etherboot de uma placa de rede ISA<br />Para placas de rede ISA antigas, n&atilde;o importa muito a determina&ccedil;&atilde;o de seu modelo exato. Antes de tudo, a maior parte delas s&atilde;o placas ne2000 ou 3Com 3c509. Voc&ecirc; precisa apenas escolher o driver Etherboot correto, aquele que seleciona o tipo de m&iacute;dia nas placas ambas 10 base-2 (Coaxial) and 10 base-T (Par Tran&ccedil;ado).<br /><br />3.2.2. Escolhendo um driver Etherboot de uma placa de rede PCI<br />Para placas PCI, &eacute; importante que voc&ecirc; escolha o driver Etherboot driver correspondente ao fabricante e o seu identificador da placa de rede (Vendor and Device id)<br />As vezes voc&ecirc; ter&aacute; sorte. Saber&aacute; exatamente qual modelo de placa voc&ecirc; tem, porque o n&uacute;mero do modelo est&aacute; impresso na placa, e corresponde exatamente &agrave; descri&ccedil;&atilde;o de um dos m&oacute;dulos Etherboot. Por&eacute;m, em muitos casos, voc&ecirc; ter&aacute; que achar os n&uacute;meros identidficadores da PCI.<br />Caso suas esta&ccedil;&otilde;es de trabalho tenham um driver de disquete, voc&ecirc; pode iniciar um disquete tomsrtbt (Tom's Root Boot). Ou, se suas esta&ccedil;&otilde;es de trabalho t&ecirc;m um driver de CD-ROM, vov&ecirc; pode inicializar de um CD Knoppix. Se voc&ecirc; n&atilde;o puder instalar linux em suas esta&ccedil;&otilde;es de trabalho, ent&atilde;o sua &uacute;nica esperan&ccedil;a talvez seja mover a placa de rede para uma m&aacute;quina que possa inicializar linux.<br />Quando voc&ecirc;&nbsp; tiver inicializado em Linux, poder&aacute; usar o comando lspci com a op&ccedil;&atilde;o '-n'.<br />[root@jamlap root]# lspci -n<br />0000:00:00.0 Class 0600: 8086:7190 (rev 03)<br />0000:00:01.0 Class 0604: 8086:7191 (rev 03)<br />0000:00:03.0 Class 0607: 104c:ac1c (rev 01)<br />0000:00:03.1 Class 0607: 104c:ac1c (rev 01)<br />0000:00:07.0 Class 0680: 8086:7110 (rev 02)<br />0000:00:07.1 Class 0101: 8086:7111 (rev 01)<br />0000:00:07.2 Class 0c03: 8086:7112 (rev 01)<br />0000:00:07.3 Class 0680: 8086:7113 (rev 03)<br />0000:00:08.0 Class 0401: 125d:1978 (rev 10)<br />0000:01:00.0 Class 0300: 1002:4c4d (rev 64)<br />0000:06:00.0 Class 0200: 8086:1229 (rev 09)<br /><br />No examplo acima, voc&ecirc; pode ver uma entrada para cada placa PCI no sistema. Voc&ecirc; apenas precisa notar os m&oacute;dulos Class 0200. Ent&atilde;o, se digitar novamente o comando, especificando somente as interfaces Ethernet, a lista torna-se muito mais administr&aacute;vel.<br />[root@jamlap root]# lspci -n | grep &quot;Class 0200&quot;<br />0000:06:00.0 Class 0200: 8086:1229 (rev 09)<br /><br />Os n&uacute;meros de ID do PCI s&atilde;o: 8086:1229. O primeiro campo, 8086 &eacute; a ID do fabricante PCI. Neste example, o fabricante &eacute; a Corpora&ccedil;&atilde;o Intel. O segundo campo, 1229 &eacute; a ID do m&oacute;dulo PCI. Este n&uacute;mero nos informa que modelo &eacute; a placa de rede. Neste caso, uma placa EtherExpress 100.<br /><br />3.2.3. Criando um disquete de boot<br />Voc&ecirc; pode baixar um pacote Etherboot e configur&aacute;-lo para o tipo de bootrom que voc&ecirc; precisa. Ent&atilde;o, voc&ecirc; pode compilar o c&oacute;digo para produzir uma imagem de bootrom que pode ser escrita em uma EPROM, ou em um disquete.<br />Um modo bem mais simples pode ser encontrado no site de Marty Connor <a href="http://www.rom-o-matic.net/" title="www.Rom-O-Matic.net" rel="nofollow">www.Rom-O-Matic.net</a>.<br />Marty fez um excelente trabalho em criar uma interface web para o processo de configura&ccedil;&atilde;o e compila&ccedil;&atilde;o de imagens bootrom com Etherboot. Neste site, voc&ecirc; pode selecionar que tipo de placa de rede voc&ecirc; tem, e que tipo de imagem voc&ecirc; quer. Ent&atilde;o, voc&ecirc; tem a oportunidade de modificar diferentes&nbsp; op&ccedil;&otilde;es de configura&ccedil;&atilde;o Etherboot. Depois disso voc&ecirc; clica no bot&atilde;o 'Get ROM' (Pegue a ROM) e uma imagem bootrom customizada ser&aacute; gerada enquanto voc&ecirc; espera.<br />Para o formato de sa&iacute;da da ROM (output format), escolha 'Floppy Bootable ROM Image' (Imagem ROM de Disquete Inicializ&aacute;vel). Esta op&ccedil;&atilde;o incluir&aacute; um cabe&ccedil;alho de 512 bites que &eacute; um boot-loader para carregar a imagem etherboot na ram onde pode ser executada.<br />Clique no bot&atilde;o 'Get ROM'. A imagem de bootrom image ser&aacute; gerada em poucos segundos. Quando completa, seu navegador abrir&aacute; uma janela pop-up com a op&ccedil;&atilde;o &quot;Save As&quot; (Salvar Como), onde voc&ecirc; pode designar onde voc&ecirc; quer salvar&nbsp; a imagem no seu computador.<br />Ap&oacute;s salvar a imagem no seu disco r&iacute;gido, voc&ecirc; precisa tamb&eacute;m grav&aacute;-la em um disquete. Insira este disquete em seu driver e digite o seguinte comando:<br />dd if=Etherboot_Image of=/dev/fd0<br /><br />3.2.4. Criando um bootrom<br />Escrever uma imagem Etherboot para uma EPROM requer um programador EPROM. Este &eacute; um equipamento que varia de pre&ccedil;o de centenas a milhares de d&oacute;lares, dependendo de suas caracter&iacute;sticas.<br />O processo de criar uma bootrom &eacute; inteiramente dependente do programador EPROM. E est&aacute; al&eacute;m do escopo deste documento.<br /><br />Cap&iacute;tulo 4. Rodando as esta&ccedil;&otilde;es de trabalho<br />Supondo que o servidor e as esta&ccedil;&otilde;es de trabalho est&atilde;o configuradas corretamente, voc&ecirc; precisar&aacute; somente inserir o disquete de boot no driver de disquete, e ligar a esta&ccedil;&atilde;o de trabalho.<br />O c&oacute;digo Etherboot ser&aacute; lido do disquete para a mem&oacute;ria, a placa de rede ser&aacute; achada e inicializada, o&nbsp; pedido de dhcp ser&aacute; enviado para a rede, uma resposta ser&aacute; enviada do servidor, e o kernel ser&aacute; baixado para as esta&ccedil;&otilde;es. Quando o kernel inicializar o hardware das esta&ccedil;&otilde;es de trabalho, janelas X (X Windows) come&ccedil;ar&atilde;o e um box de login aparecer&aacute; na esta&ccedil;&atilde;o de trabalho, parecido com o exemplo abaixo.<br /><br />Figura 4-1. Tela de Login<br />Neste ponto, voc&ecirc; pode se logar. Um coisa importante de ter em mente &eacute; que voc&ecirc; est&aacute; logando no servidor. Todos os comandos que voc&ecirc; rodar estar&atilde;o de fato rodando neste servidor, tendo como interface de sa&iacute;da as esta&ccedil;&otilde;es de trabalho. Este &eacute; o poder das janelas X (X windows).<br />Voc&ecirc; pode rodar qualquer programa que seja suportado pelo servidor.<br /><br />Cap&iacute;tulo 5. Imprimindo<br />Sem considerar o fato de que as esta&ccedil;&otilde;es de trabalho s&atilde;o GUI totalmente operacionais ou character mode terminal, tamb&eacute;m podem funcionar como servidores de impress&atilde;o, permitindo com que at&eacute; tr&ecirc;s impressoras sejam conectados &agrave;s portas paralelas e seriais.<br />Isto &eacute; tudo transparente para o usu&aacute;rio das esta&ccedil;&otilde;es de trabalho. Eles nem notar&atilde;o o pequeno volume de tr&aacute;fego que est&aacute; passando das esta&ccedil;&otilde;es de trabalho at&eacute; as impressoras.<br /><br />5.1. Setup cliente<br />LTSP usa o programa lp_server em suas esta&ccedil;&otilde;es de trabalho, para redirecionar trabalhos de impress&atilde;o do servidor &agrave; impressora conectada &agrave; uma das portas de esta&ccedil;&atilde;o.&nbsp; daemon<br />Para permitir a impressora nas esta&ccedil;&otilde;es, existe uma s&eacute;rie de entradas de configura&ccedil;&atilde;o no arquivo lts.conf.<br />[ws001]<br />&nbsp;&nbsp;&nbsp; PRINTER_0_DEVICE = /dev/lp0<br />&nbsp;&nbsp;&nbsp; PRINTER_0_TYPE&nbsp;&nbsp; = P<br />A entrada acima far&aacute; com que o programa lp_server rode como um daemon, escutando na porta 9100 TCP/IP um fluxo de impress&atilde;o (stream) do servidor. O dado de impress&atilde;o ser&aacute; ent&atilde;o redirecionado &agrave; impressora conectada &agrave; porta paralela /dev/lp0.<br />Existem muitas outras op&ccedil;&otilde;es dispon&iacute;veis. Cheque a se&ccedil;&atilde;o do arquivo lts.conf a seguir neste documento para mais informa&ccedil;&otilde;es sobre as entradas de configura&ccedil;&atilde;o da impressora.<br /><br />5.2. Setup Servidor<br />Configurandi a impressora no servidor &eacute; feita somente definindo a fila de impress&atilde;o, usando a ferramenta de configura&ccedil;&atilde;o da impressora no servidor.<br />No Redhat 7.2,&nbsp; existe uma ferramenta de configura&ccedil;&atilde;o da impressora tanto em GUI quanto em modo texto. A ferramenta GUI&nbsp; &eacute; chamada de printconf-gui, e a ferramenta modo texto printconf-tui. Vers&otilde;es mais antigas do Redhat t&ecirc;m um programa chamado printtool. Printtool tamb&eacute;m existe no Redhat 7.2, mas se chamar&aacute; printconf-gui. Outras distribui&ccedil;&otilde;es Linux t&ecirc;m suas pr&oacute;prias ferramentas de configura&ccedil;&atilde;o de impress&atilde;o.<br /><br />Figura 5-1. Printconf-gui Adicionando uma nova impressora<br />Quando voc&ecirc; inicia a sua ferramenta de configura&ccedil;&atilde;o da impressora, voc&ecirc; precisa adicionar uma nova impressora. O programa lp_server permite com que as esta&ccedil;&otilde;es de trabalho emulem um servidor de impress&atilde;o HP JetDirect.&nbsp; Voc&ecirc; s&oacute; precisa criar uma impressora JetDirect.<br />Voc&ecirc; precisa dar &agrave; impressora um nome de fila (Queue name). O nome pode ser qualquer coisa, mas que tenha um significado, e conter apenas os seguintes caracteres:<br />&quot;a-z&quot; caixa baixa<br />&quot;A-Z&quot; caixa alta<br />&quot;0-9&quot; n&uacute;meros<br />&quot;-&quot;&nbsp;&nbsp; h&iacute;fen<br />&quot;_&quot;&nbsp;&nbsp; underscore<br />O nome escolhido no example abaixo &eacute; ws001_lp . O nome torna f&aacute;cil ver qual impressora est&aacute; associada com ws001.<br /><br />Figura 5-2. Printconf-gui Detalhe de informa&ccedil;&atilde;o<br />Existem dois campos requisitados para se comunicar com a impressora:<br />1.Endere&ccedil;o IP ou hostname da esta&ccedil;&atilde;o de trabalho com que a impressora est&aacute; associada.<br />2.A porta TCP em que o daemon lp_server est&aacute; escutando.<br />A primeira impressora que voc&ecirc; conectar &agrave; esta&ccedil;&atilde;o de trabalho ser&aacute; na porta 9100 TCP/IP. A segunda impressora ser&aacute; na porta 9101, e a terceira impressora na porta 9102 .<br /><br />Cap&iacute;tulo 6. Scripts de Tela<br />Uma novidade do LTSP que foi adicionado na vers&atilde;o 4.0 &eacute; algo chamado de Screen Scripts. Estes s&atilde;o scripts para come&ccedil;ar v&aacute;rios tipos de sess&otilde;es.<br />Voc&ecirc; pode especificar m&uacute;ltiplos scripts de tela para uma esta&ccedil;&atilde;o de trabalho. Fazendo isto, voc&ecirc; permitir&aacute; m&uacute;ltiplas sess&otilde;es. Estes podem ser diferentes tipos de sess&atilde;o, ou sess&otilde;es do mesmo tipo. Por&nbsp; examplo, voc&ecirc; pode especificar o seguinte:<br />&nbsp;&nbsp; SCREEN_01 = startx<br />&nbsp;&nbsp; SCREEN_02 = shell<br />Isso iniciar&aacute; o servidor X na primeira tela, e um shell prompt na segunda tela. Voc&ecirc; pode trocar entre telas pressionando Ctrl-Alt-F1 para ir para primeira tela, e Ctrl-Alt-F2 para a segunda tela.<br />Voc&ecirc; pode especificar at&eacute; 12 scripts de tela para cada esta&ccedil;&atilde;o de trabalho, por&eacute;ma&nbsp; maior parte das pessoas tem somente uma.<br />Tipos de scripts de tela:<br />startx<br />Este script iniciar&aacute; o servidor X com uma op&ccedil;&atilde;o -query, para mandar um pedido de XDMCP para um gerenciador de display, obtendo assim um box de login na tela.<br />shell<br />Este script iniciar&aacute; um shell no terminal. Isso &eacute; realmente usado com a inten&ccedil;&atilde;o de descobrir problemas (troubleshooting) nas esta&ccedil;&otilde;es de trabalho. Porque fornece a voc&ecirc; uma se&ccedil;&atilde;o no cliente leve, no lugar do servidor, n&atilde;o &eacute; muito &uacute;til para rodar aplicativos.<br />telnet<br />Este script iniciar&aacute; uma se&ccedil;&atilde;o telnet que conectar&aacute; ao servidor. Isso lhe dar&aacute; uma sess&atilde;o baseada em caracteres no servidor.<br />Por padr&atilde;o, telnet conectar&aacute; ao servidor LTSP. caso voc&ecirc; deseje especificar um servidor diferente, voc&ecirc; pode faz&ecirc;-lo na mesma linha do script de tela. Por examplo:<br />&nbsp;&nbsp;&nbsp; SCREEN_01 = telnet server2.mydomain.com<br />Voc&ecirc; tamb&eacute;m pode especificar quantas op&ccedil;&otilde;es o Telnet conhe&ccedil;a, por&eacute;m, caso voc&ecirc; especifique outras op&ccedil;&otilde;es, voc&ecirc; deve tamb&eacute;m especificar o servidor a ser conectado.<br />rdesktop<br />Este script acionar&aacute; o programa rdesktop, que ir&aacute; por sua vez conectar a um servidor which Microsoft Window. Voc&ecirc; pode especificar&nbsp; quantas op&ccedil;&otilde;es rdesktop vpc&ecirc; quer na mesma linha, diretamente depois do nome do script de tela. Por examplo, se voc&ecirc; quer especificar o servidor a ser conectado, voc&ecirc; pode fazer assim:<br />&nbsp;&nbsp;&nbsp; SCREEN_01 = rdesktop -f w2k.mydomain.com<br />O examplo acima iniciar&aacute; o rdesktop em modo tela cheia. O usu&aacute;rio ver&aacute; uma janela de login, e ter&aacute; que logar somente uma vez. Isso &eacute; muito &uacute;til quando voc&ecirc; apenas quer uma kanela de login, sem ter&nbsp; um login Linux ou um gerenciador de janelas.&nbsp; O usu&aacute;rio nem saber&aacute; que est&aacute; rodando Linux.<br />O script de tela est&aacute; localizado no diret&oacute;rio the /opt/ltsp/i386/etc/screen.d. Voc&ecirc; pode criar seu pr&oacute;prio script de tela e coloc&aacute;-lo neste diret&oacute;rio. &Eacute; recomend&aacute;vel seguir um dos scripts existentes como exemplo.<br />Cap&iacute;tulo 7. Desproblematizando<br />Caso, mesmo tendo seguido todos os cap&iacute;tulos anteriores, suas esta&ccedil;&otilde;es de trabalho n&atilde;o funcionem, ent&atilde;o voc&ecirc; deve iniciar o processo de desproblematizar a instala&ccedil;&atilde;o.<br />A primeira coisa a fazer &eacute; descobrir at&eacute; que ponto as esta&ccedil;&otilde;es de trabalho foram em seu boot.<br /><br />7.1. Desproblematizando a imagem de disquete Etherboot<br />Quando voc&ecirc; inicializa pelo disquete, voc&ecirc; deve ver algo parecido com isso:<br />loaded ROM segment 0x0800 length 0x4000 reloc 0x9400<br />Etherboot 5.0.1 (GPL) Tagged ELF for [LANCE/PCI]<br />Found AMD Lance/PCI at 0x1000, ROM address 0x0000<br />Probing...[LANCE/PCI] PCnet/PCI-II 79C970A base 0x1000, addr 00:50:56:81:00:01<br />Searching for server (DHCP)...<br />&lt;sleep&gt;<br />O examplo acima mostra o que voc&ecirc; deve esperar ver na tela quando inicializando pelo disquete. Caso voc&ecirc; n&atilde;o veja estas mensagens, indicando que o Etherboot come&ccedil;ou, talvez vocv&ecirc; tenha um disquete&nbsp; ruim, ou a imagem n&atilde;o foi gravada propriamente.<br />Caso a seguinte mensagem apare&ccedil;a, ent&atilde;o indica que voc&ecirc; provavelmente gerou uma imagem que n&atilde;o corresponde &agrave; sua placa de rede.<br />ROM segment 0x0800 length 0x8000 reloc 0x9400<br />Etherboot 5.0.2 (GPL) Tagged ELF for [Tulip]<br />Probing...[Tulip]No adapter found<br />&lt;sleep&gt;<br />&lt;abort&gt;<br />Caso chegue ao ponto em que detecta a placa de rede e mostra o endere&ccedil;o MAC correto, ent&atilde;o o disquete provavelmente est&aacute; bom.<br /><br />7.2. Desproblematizando DHCP<br />Uma vez que a placa de rede foi incializada, esta enviar&aacute; uma transmiss&atilde;o DHCP para a rede local, procurando por um servidor DHCP.<br />Caso a esta&ccedil;&atilde;o de trabalho consiga uma resposta v&aacute;lida do servidor DHCP server, configurar&aacute; ent&atilde;o a placa de rede. Voc&ecirc; pode dizer se funcionou direito caso a informa&ccedil;&atilde;o do endere&ccedil;o IP apare&ccedil;a na tela. Segue um exemplo de como deve aparecer:<br />ROM segment 0x0800 length 0x4000 reloc 0x9400<br />Etherboot 5.0.1 (GPL) Tagged ELF for [LANCE/PCI]<br />Found AMD Lance/PCI at 0x1000, ROM address 0x0000<br />Probing...[LANCE/PCI] PCnet/PCI-II 79C970A base 0x1000, addr 00:50:56:81:00:01<br />Searching for server (DHCP)...<br />&lt;sleep&gt;<br />Me: 192.168.0.1, Server: 192.168.0.254, Gateway 192.168.0.254<br />caso voc&ecirc; veja uma linha que come&ccedil;a com 'Me:', seguido de um endere&ccedil;o IP, ent&atilde;o voc&ecirc; sabe que o DHCP est&aacute; funcionando corretamente. Voc&ecirc; pode seguir ent&atilde;o para checar se o TFTP est&aacute; funcionando.<br />Se caso contr&aacute;rio, voc&ecirc; veja a mensagem seguinte em sua esta&ccedil;&atilde;o de trabalho, seguido de uma s&eacute;rie de mensagens &lt;sleep&gt;, ent&atilde;o algo est&aacute; errado. No enatnto, &eacute; comum ver uma ou duas mensagens de &lt;sleep&gt;, depois da qual o servidor dhcp responde.<br />Searching for server (DHCP)...<br />Descobrir o que est&aacute; errado pode ser muitas vezes dif&iacute;cil, mas aqui seguem algumas dicas.<br /><br />7.2.1. Checar as conex&otilde;es<br />A esta&ccedil;&atilde;o de trabalho est&aacute; conectada fisicamente &agrave; mesma rede que o servidor est&aacute; conectado?<br />Com as esta&ccedil;&otilde;es de trabalho ligadas, certifique-se de que as luzes de link est&atilde;o acesas &agrave; todas as conex&otilde;es.<br />Se voc&ecirc; est&aacute; conectando diretamente as esta&ccedil;&otilde;es de trabalho e o servidor (sem um hub ou switch), certifique-se que vc est&aacute; usando um cabo cruzado. Se voc&ecirc; est&aacute; usando um hub ou switch, ent&atilde;o voc&ecirc; est&aacute; usando um cabo normal (straight-thru), ambos entre as esta&ccedil;&otilde;es de trabalho e o hub, e tamb&eacute;m entre o hub e o servidor.<br /><br />7.2.2. O dhcpd est&aacute; funcionando?<br />Voc precisa determinar se o dhcpd est&aacute; funcionando no servidor. N&oacute;s podemos achar esta resposta de duas formas.<br />dhcpd normalmente fica no plano de fundo, escutando na udp porta 67. Tente dar o comando netstat para ver se algu&eacute;m est&aacute; escutando naquela porta:<br />netstat -an | grep &quot;:67 &quot;<br />Voc&ecirc; deve obter uma resposta parecida com esta:<br />udp&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0.0.0.0:67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0:*<br />A quarta coluna mostra o endere&ccedil;o de IP e a porta, separadada por um sinal de dois pontos (':'). Um endere&ccedil;o somente zeros ('0.0.0.0') indica que ele est&aacute; escutando em todas as interfaces. Isso significa que, voc deve ter uma interface eth0 e eth1, e que o dhcpd esta escutando em ambas as interfaces.<br />Mas n&atilde;o &eacute; porque o netstat mostra que tem algo escutando udp na porta 67, que significa que &eacute; definitivamente o dhcpd que est&aacute; escutando. Pode ser o bootpd, mas &eacute; muito improv&aacute;vel, porque&nbsp; bootp n&atilde;o est&aacute; mais incluido na maior parte das distribui&ccedil;&otilde;es Linux.<br />Para ter certeza que &eacute; o dhcpd que est&aacute; trabalhando, tente dar o comando ps.<br />ps aux | grep dhcpd<br />Voc&ecirc; deve obter uma resposta parecida com esta:<br />root 23814 0.0 0.3 1676 820 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S 15:13 0:00 /usr/sbin/dhcpd<br />root 23834 0.0 0.2 1552 600 pts/0&nbsp; S 15:52 0:00 grep dhcp<br />A primeira linha mostra que o dhcpd est&aacute; rodando. A segunda &eacute; apenas o seu comando grep.<br />Se voc&ecirc; n&atilde;o v&ecirc; as linhas que mostram o dhcpd rodando, ent&atilde;o voc&ecirc; precisa chcar se o servidor est&aacute; configurado para runlevel 5, e que dhcpd est&aacute; configurado para come&ccedil;ar em runlevel 5. Nos sistemas baseados em Redhat, voc&ecirc; pode tentar o ntsysv e descer at&eacute; se certificar que o dhcpd est&aacute; configurado para come&ccedil;ar.<br />Voc&ecirc; pode tentar come&ccedil;ar o dhcpd com este comando:<br />service dhcpd start<br />Preste aten&ccedil;&atilde;o na resposta, poder&aacute; mostrar erros.<br /><br />7.2.3. Checar de novo a configura&ccedil;&atilde;o dhcpd<br />O arquivo/etc/dhcpd.conf tem uma entrada para a sua esta&ccedil;&atilde;o de trabalho?<br />Voc&ecirc; deve checar novamente a configura&ccedil;&atilde;o de 'fixed-address' no seu arquivo config, para ter certeza que bate exatamente com a placa na esta&ccedil;&atilde;o de trabalho.<br /><br />7.2.4.&nbsp; ipchains ou iptables est&aacute; bloqueando o seu pedido?<br />7.2.4.1. Checando ipchains<br />Digite o seguinte comando para ver o que responde:<br />ipchains -L -v<br />Caso voc&ecirc; obtenha uma resposta assim:<br />Chain input (policy ACCEPT: 229714 packets, 115477216 bytes):<br />Chain forward (policy ACCEPT: 10 packets, 1794 bytes):<br />Chain output (policy ACCEPT: 188978 packets, 66087385 bytes):<br />Ent&atilde;o n&atilde;o &eacute; o ipchains que est&aacute; bloqueando o caminho.<br /><br />7.2.4.2. Checando iptables<br />Digite o seguinte comando para ver o que responde:<br />iptables -L -v<br />Caso voc&ecirc; obtenha uma resposta assim:<br />Chain INPUT (policy ACCEPT 18148 packets, 2623K bytes)<br />&nbsp;pkts bytes target&nbsp;&nbsp;&nbsp;&nbsp; prot opt in&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destination<br /><br />Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)<br />&nbsp;pkts bytes target&nbsp;&nbsp;&nbsp;&nbsp; prot opt in&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destination<br /><br />Chain OUTPUT (policy ACCEPT 17721 packets, 2732K bytes)<br />&nbsp;pkts bytes target&nbsp;&nbsp;&nbsp;&nbsp; prot opt in&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destination<br />Ent&atilde;o n&atilde;o &eacute; o iptables que est&aacute; bloqueando o caminho.<br /><br />7.2.5. A esta&ccedil;&atilde;o de trabalho est&aacute; mandando o pedido?<br />Olhe o arquivo /var/log/messages enquanto a esta&ccedil;&atilde;o de trabalho est&aacute; inicializando. Voc&ecirc; pode fazer isto com o seguinte comando:<br />tail -f /var/log/messages<br />Isso ir&aacute; 'seguir' o arquivo de log enquanto novas adi&ccedil;&otilde;es s&atilde;o feitas a ele.<br />server dhcpd: DHCPDISCOVER from 00:50:56:81:00:01 via eth0<br />server dhcpd: no free leases on subnet WORKSTATIONS<br />server dhcpd: DHCPDISCOVER from 00:50:56:81:00:01 via eth0<br />server dhcpd: no free leases on subnet WORKSTATIONS<br />Caso voc&ecirc; veja mensagens como estas acima dizendo 'no free leases', isso indica que o dhcpd est&aacute; rodando, mas n&atilde;o sabe nada sobre as esta&ccedil;&otilde;es de trabalho que est&atilde;o pedindo um endere&ccedil;o de IP.<br /><br />7.3. Desproblematizando TFTP<br />Etherboot usa TFTP para obter um kernel Linux do servidor. Isso &eacute; im protocolo razoavelmente simples, mas pode as vezes dar problemas para come&ccedil;ar a funcionar.<br />Caso voc&ecirc; veja uma mensagem como esta:<br />Loading 192.168.0.254:/lts/vmlinuz-2.4.24-ltsp-4.........<br />com pontos enchendo a tela rapidamente, isso normalmente indica que o TFTP est&aacute; funcionando normalmente, e o kernel est&aacute; sendo baixado.<br />Se, caso contr&aacute;rio, voc&ecirc; n&atilde;o ver os pontos, ent&atilde;o existe um problema. Poss&iacute;veis problemas incluem:<br /><br />7.3.1. tftpd n&atilde;o erst&aacute; rodando<br />Se o tftpd n&atilde;o est&aacute; configurado para rodar, ent&atilde;o certamente n&atilde;o ser&aacute; poss&iacute;vel que a esta&ccedil;&atilde;o de trabalho obtenha uma resposta para o seu pedido. Voc&ecirc; pode ver se ele est&aacute; rodando com o comando&nbsp; netstat, assim:<br />[root@bigdog]# netstat -anp | grep &quot;:69 &quot;<br /><br />udp&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0 0.0.0.0:69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 453/inetd<br /><br />Caso voc&ecirc; n&atilde;o obtenha nenhuma resposta para este comando, ent&atilde;o provavelmente tftpd n&atilde;o est&aacute; rodando.<br />Existem dois m&eacute;todos comuns para chamar o tftpd, eles s&atilde;o o inetd e o mais novo xinetd<br />inetd usa o arquivo de configura&ccedil;&atilde;o chamado /etc/inetd.conf. Neste arquivo, certifique-se que a linha para come&ccedil;ar o tftpd N&Atilde;O est&aacute; comentada. A linha deve se parecer com esta:<br />tftp dgram udp wait nobody /usr/sbin/tcpd&nbsp; /usr/sbin/in.tftpd -s /tftpboot<br /><br />xinetd usa um diret&oacute;rio de arquivos de configura&ccedil;&atilde;o individuais. Um arquivo para cada servi&ccedil;o. Se o seu servidor est&aacute; usando xinetd, ent&atilde;o o arquivo de configura&ccedil;&atilde;o para o tftpd se chama /etc/xinetd.d/tftp. Abaixo est&aacute; um exemplo:<br />service tftp<br />{<br />&nbsp; disable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = no<br />&nbsp; socket_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = dgram<br />&nbsp; protocol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = udp<br />&nbsp; wait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = yes<br />&nbsp; user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = root<br />&nbsp; server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = /usr/sbin/in.tftpd<br />&nbsp; server_args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = -s /tftpboot<br />}<br /><br />Certifique-se que a linha disable n&atilde;o diz yes.<br /><br />7.3.2. O kernel n&atilde;o est&aacute; onde o tftpd espera encontr&aacute;-lo<br />O kernel precisa estar em um lugar que o daemon tftpd pode acess&aacute;-lo. Caso a op&ccedil;&atilde;o '-s' esteja especificada para a se&ccedil;&atilde;o daemon tftpd, ent&atilde;o tudo que a esta&ccedil;&atilde;o de trabalho est&aacute; pedindo deve estar relativo ao /tftpboot. Ent&atilde;o se a entrada filename no arquivo /etc/dhcpd.conf est&aacute; marcada como /lts/vmlinuz-2.4.24-ltsp-4, ent&atilde;o o kernel precisa ser /tftpboot/lts/vmlinuz-2.4.24-ltsp-4<br /><br />7.4. Desproblematizando o sistema de arquivos root NFS<br />Existem v&aacute;rias coisas que podem prevenir um sistema de arquivos root de ser montado. Incluindo os seguintes:<br /><br />7.4.1. init n&atilde;o achado<br />Caso voc&ecirc; obtenha o seguinte erro:<br />Kernel panic: No init found.&nbsp; Try passing init= option to kernel.<br />Ent&atilde;o provavelmente voc&ecirc; est&aacute; montando o diret&oacute;rio errado como o sistema de arquivos root, ou o diret&oacute;rio /opt/ltsp/i386 est&aacute; vazio.<br /><br />7.4.2. Servidor retornou erro -13<br />Caso voc&ecirc; obtenha o seguinte erro:<br />Root-NFS: Server returned error -13 while mounting /opt/ltsp/i386<br />Isso indica que o diret&oacute;rio /opt/ltsp/i386 n&atilde;o est&aacute; listado no arquivo /etc/exports.<br />Olhe o arquivo /var/log/messages para ver se fornece alguma pista. Uma entrada como esta:<br />Jul 20 00:28:39 bigdog rpc.mountd: refused mount request from ws004<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for /opt/ltsp/i386 (/): no export entry<br />Que ent&atilde;o confirma a nossa suspeita que a entrada em /etc/exports n&atilde;o est&aacute; correta.<br /><br />7.4.3. Problemas de Daemon NFS (portmap, nfsd &amp; mountd)<br />NFS pode ser um servi&ccedil;o complexo e dif&iacute;cil para desproblematizar, mas entendendo o que deveria ser a configura&ccedil;&atilde;o inicial e que ferramentas existem dispon&iacute;veis para diagnosticar os problemas, certamente ir&aacute; ajud&aacute;-lo a fazer isto mais f&aacute;cil.<br />Existem tr&ecirc;s daemons que precisam estar rodando no servidor para que o NFS funcione corretamente: o portmap, nfsd e o mountd.<br /><br />7.4.3.1. O Portmapper (portmap)<br />Caso voc&ecirc; obtenha a seguinte mensagem:<br />Looking up port of RPC 100003/2 on 192.168.0.254<br />portmap: server 192.168.0.254 not responding, timed out<br />Root-NFS: Unable to get nfsd port number from server, using default<br />Looking up port of RPC 100005/2 on 192.168.0.254<br />portmap: server 192.168.0.254 not responding, timed out<br />Root-NFS: Unable to get mountd port number from server, using default<br />mount: server 192.168.0.254 not responding, timed out<br />Root-NFS: Server returned error -5 while mounting /opt/ltsp/i386<br />VFS: unable to mount root fs via NFS, trying floppy.<br />VFS: Cannot open root device &quot;nfs&quot; or 02:00<br />Please append a correct &quot;root=&quot; boot option<br />Kernel panic: VFS: Unable to mount root fs on 02:00<br />Isso &eacute; provavelmente causado pelo n&atilde;o-funcionamento do daemon portmap. Voc&ecirc; pode confirmar se o&nbsp; portmapper est&aacute; rodando atrav&eacute;s do comando ps:<br />ps -e | grep portmap<br />Caso o portmapper esteja rodando, voc&ecirc; deve obter uma resposta assim:<br />30455 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:00 portmap<br />Outro teste &eacute; usar o netstat. O portmapper usa TCP e UDP na porta 111. Tente isso:<br />netstat -an | grep &quot;:111 &quot;<br />Voc&ecirc; deve obter uma resposta assim:<br />tcp&nbsp;&nbsp; 0&nbsp;&nbsp; 0 0.0.0.0:111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br />udp&nbsp;&nbsp; 0&nbsp;&nbsp; 0 0.0.0.0:111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0:*<br />Caso sua resposta n&atilde;o seja parecida com esta, ent&atilde;o o portmapper n&atilde;o est&aacute; funcionando. Voc&ecirc; deve iniciar o portmapper assim:<br />/etc/rc.d/init.d/portmap&nbsp;&nbsp; start<br />Ent&atilde;o, voc&ecirc; deve certificar-se que o portmapper est&aacute; configurado para come&ccedil;ar quando o servidor inicializar. Rode ntsysv para ter certeza que est&aacute; indicado para rodar.<br /><br />7.4.3.2. Os daemons NFS e MOUNT (nfsd &amp; mountd)<br />NFS tem 2 daemons que precisam estar rodando. nfsd e mountd. Ambos s&atilde;o iniciados pelo script /etc/rc.d/init.d/nfs.<br />Voc&ecirc; pode dar o comando ps para se certificar que eles est&atilde;o rodando.<br />ps -e | grep nfs<br />ps -e | grep mountd<br />Caso mostre que um ou dois destes daemons n&atilde;o est&atilde;o rodando, ent&atilde;o voc&ecirc; precisa inici&aacute;-los.<br />Normalmente, voc&ecirc; pode rodar um script de inicializa&ccedil;&atilde;o com o argumento restart para fazer com que ambos inicializem, mas, se por alguma raz&atilde;o, o script /etc/rc.d/init.d/nfs n&atilde;o re-inicia o&nbsp; nfsd dessa forma, s&oacute; re-iniciando mountd (bug?). Ent&atilde;o, voc&ecirc; deve dar a seguinte sequ&ecirc;ncia de comandos:<br />/etc/rc.d/init.d/nfs&nbsp; stop<br />/etc/rc.d/init.d/nfs&nbsp; start<br />Voc&ecirc; pode obter erros no comando stop, mas isso &eacute; Ok. O comando start deve mostrar o status OK.<br />Caso os daemons estejam rodando, mas o NFS ainda n&atilde;o fiunciona, voc&ecirc; pode verificar que eles se registraram com o portmapper atrav&eacute;s do comando rpcinfo.<br />rpcinfo -p localhost<br />Voc&ecirc; deve obter respostas como as seguintes:<br />program vers proto&nbsp;&nbsp; port<br />&nbsp;100000&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; tcp&nbsp;&nbsp;&nbsp; 111&nbsp; portmapper<br />&nbsp;100000&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; udp&nbsp;&nbsp;&nbsp; 111&nbsp; portmapper<br />&nbsp;100003&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; udp&nbsp;&nbsp; 2049&nbsp; nfs<br />&nbsp;100003&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; udp&nbsp;&nbsp; 2049&nbsp; nfs<br />&nbsp;100021&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; udp&nbsp; 32771&nbsp; nlockmgr<br />&nbsp;100021&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; udp&nbsp; 32771&nbsp; nlockmgr<br />&nbsp;100021&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; udp&nbsp; 32771&nbsp; nlockmgr<br />&nbsp;100005&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; udp&nbsp;&nbsp;&nbsp; 648&nbsp; mountd<br />&nbsp;100005&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; tcp&nbsp;&nbsp;&nbsp; 651&nbsp; mountd<br />&nbsp;100005&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; udp&nbsp;&nbsp;&nbsp; 648&nbsp; mountd<br />&nbsp;100005&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; tcp&nbsp;&nbsp;&nbsp; 651&nbsp; mountd<br />&nbsp;100005&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; udp&nbsp;&nbsp;&nbsp; 648&nbsp; mountd<br />&nbsp;100005&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; tcp&nbsp;&nbsp;&nbsp; 651&nbsp; mountd<br />&nbsp;100024&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; udp&nbsp;&nbsp;&nbsp; 750&nbsp; status<br />&nbsp;100024&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; tcp&nbsp;&nbsp;&nbsp; 753&nbsp; status<br />Isso indica que o nfs (nfsd) e o mountd est&atilde;o ambos rodando e se registraram com o portmapper.<br /><br />7.5. Desproblematizando o Xserver<br />Ai, ai... provavelmente a parte mais dif&iacute;cil de configurar uma esta&ccedil;&atilde;o de trabalho LTSP, &eacute; fazer com que o servidor X esteja configurado direito. Se voc&ecirc; est&aacute; usando uma placa de v&iacute;deo nova, que &eacute; suportada pelo Xorg Xservers, e voc&ecirc; tem um novo monitor que suporta uma larga margem de frequ&ecirc;ncias e resolu&ccedil;&otilde;es, ent&atilde;o isso &eacute; muito direto. Usualmente, neste caso, quando n&atilde;o funciona, &eacute; muito prov&aacute;vel que seja o servidor X incorreto para aquela placa.<br />Quando um servidor X n&atilde;o funciona com a sua placa, &eacute; normalmente bem &oacute;bvio. Ou o servidor X nem come&ccedil;a, ou a imagem estar&aacute; incorreta.<br />Quando a esta&ccedil;&atilde;o de trabalho est&aacute; pronta para come&ccedil;ar o servidor X, ela chama o script startx, que inicia o servidor X nas esta&ccedil;&otilde;es de trabalho locais, com a op&ccedil;&atilde;o -query apontando para o servidor, onde um gerenciador de interface gr&aacute;fica como o XDM , GDM ou KDM est&aacute; rodando.<br />Porque o servidor X come&ccedil;a por um script startx, que por sua vez &eacute; inicializado pelo programa init program, quando falha, init tentar&aacute; rod&aacute;-lo novamente. init vai continuar em loop tentando rodar o servidor X 10 vezes, e despois desistindo, porque pensa que est&aacute; respawning muito rapidamente. Depois que finalmente desiste, a mensagem de erro do servidor X deve aparecer &agrave; esquerda na tela.<br />Esperar com que o servidor X falhe 10 vezes pode ser bem irritante, ent&atilde;o, um modo simples de evitar as flhas repetitivas &eacute; come&ccedil;ar as esta&ccedil;&otilde;es de trabalho em&nbsp; runlevel 3, para que o servidor X server N&Atilde;O comece automaticamente. ao inv&eacute;s disso, quan do voc&ecirc; inicializar as esta&ccedil;&otilde;es de trabalho, voc&ecirc; vai obter um pedido (prompt) de bash. A partir deste, voc&ecirc; pode come&ccedil;ar o servidor X manualmente com o seguinte comando:<br />sh&nbsp; /tmp/start_ws<br />O servidor X server tentar&aacute; inicializar, e depois falhar&aacute;, ent&atilde;o retornando ao pedido de bash, para que voc&ecirc; possa ver a causa da falha.<br /><br />7.6. Desproblematizando o gerenciador de interface gr&aacute;fica<br />O gerenciador de interface gr&aacute;fica &eacute; o daemon que roda no servidor, esperando com que um servidor X fa&ccedil;a contato com ele. Uma vez que o contato foi feito, ele mostrar&aacute; na tela uma entrada de login, dando @ usu&aacute;ri@ uma chance de se logar no servidor.<br />Os tr&ecirc;s gerenciadores de interface gr&aacute;fica mais comuns s&atilde;o:<br />XDM &ndash; Est&aacute; por a&iacute; desde sempre. Vem junto com o sistema de janelas X padr&atilde;o.<br />GDM &ndash; &Eacute; o 'Gnome Display Manager'. Integrante do pacote Gnome.<br />KDM &ndash; &Eacute; o 'KDE Display Manager'. Integrante do sistema K Desktop.<br />Mais recentemente, distribui&ccedil;&otilde;es GNU/Linux incluem todas as tr&ecirc;s interfaces gr&aacute;ficas.<br /><br />7.6.1. Tela cinza com um grande sinal X<br />Isto indica que o servidor X est&aacute; funcionando, mas que n&atilde;o conseguiu conectar com o gerenciador de interface gr&aacute;fica. Algumas poss&iacute;veis raz&otilde;es s&atilde;o:<br />1.O gerenciador de interface gr&aacute;fica talvez n&atilde;o esteja funcionando<br />Em vers&otilde;es recentes do Redhat (7.0 e acima), o gerenciador de interface gr&aacute;fica &eacute; inicializado do init. No arquivo /etc/inittab, existe uma linha que se parece com essa:<br />x:5:respawn:/etc/X11/prefdm -nodaemon<br />O script prefdm determinar&aacute; qual gerenciador de interface gr&aacute;fica a rodar.<br />O gerenciador de interface gr&aacute;fica padr&atilde;o depende dos pacotes que foram instalados. Se o Gnome est&aacute; instalado, ent&atilde;o o GDM &eacute; o gerenciador de interface gr&aacute;fica padr&atilde;o. Caso o Gnome n&atilde;o esteja instalado, ent&atilde;o o script prefdmvai ver se o KDE est&aacute; instalado. Caso esteja, ent&atilde;o o KDM ser&aacute; o gerenciador de interface gr&aacute;fica padr&atilde;o. Caso KDE tamb&eacute;m n&atilde;o esteja inatalado, ent&atilde;o o XDM ser&aacute; o gerenciador de interface gr&aacute;fica padr&atilde;o.<br />Usando o comando netstat, voc&ecirc; pode ver se existe um gerenciador de interface gr&aacute;fica rodando. No servidor, d&ecirc; o seguinte comando:<br />netstat -ap | grep xdmcp<br />Voc&ecirc; deve ver os resultados mostrando que existe um processo escutando na porta xdmcp&nbsp; (177).<br />udp&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0 *:xdmcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1493/gdm<br />Isso mostra claramente que o gdm est&aacute; rodando com um PID de 1493, e est&aacute; escutando na porta xdmcp.<br />Caso mostre uma linha como a abaixo, indicando que existe definitivamente um gerenciador de interface gr&aacute;fica escutando, ent&atilde;o voc&ecirc; precisa certificar-se de que as esta&ccedil;&otilde;es de trabalho est&atilde;o mandando a pergunta XDMCP para o servidor correto.<br />No arquivo lts.conf, voc&ecirc; pode ter uma entrada que especifica o endere&ccedil;o IP do servidor que est&aacute; rodando o gerenciador de interface gr&aacute;fica. A entrada &eacute; opcional, mas caso presente, deve se parecer com isso:<br />XDM_SERVER&nbsp; =&nbsp; 192.168.0.254<br />&eacute; claro que o endere&ccedil;o IP de sua rede pode ser diferente do exemplo acima.<br />Caso a entrada&nbsp; 'XDM_SERVER' n&atilde;o esteja presente, usar&aacute; o valor da entrada 'SERVER', caso presente. Caso n&atilde;o esteja presente, ent&atilde;o usar&aacute; 192.168.0.254.<br />N&atilde;o importando de qu&ecirc; forma est&aacute; especificada, voc&ecirc; s&oacute; precisa certificar-se que o endere&ccedil;o IP &eacute; o endere&ccedil;o correto do servidor rodando o gerenciador de interface gr&aacute;fica.<br />2.O gerenciador de interface gr&aacute;fica talvez esteja configurado para ignorar pedidos de hosts remotos.<br />Caso voc&ecirc; esteja certo que o gerenciador de interface gr&aacute;fica est&aacute; funcionando, ent&atilde;o &eacute; poss&iacute;vel que ele tenha sido configurado para ignorar pedidos de XDMCP de hosts remotos. Voc&ecirc; precisar&aacute; checar os arquivos de configura&ccedil;&atilde;o do gerenciador do seu interface gr&aacute;fica em espec&iacute;fico para determinar se ele est&aacute; configurado direito.<br />XDM<br />A configura&ccedil;&atilde;o padr&atilde;o para o Redhat &eacute; desabilitar a capacidade das esta&ccedil;&otilde;es de trabalho de terem acesso de login do XDM. O script ltsp_initialize far&aacute; com que isso seja revertido, mas se n&atilde;o estiver funcionando, voc&ecirc; deve checar o arquivo/etc/X11/xdm/xdm-config. Procure por uma entrada que se pare&ccedil;a com isso:<br />DisplayManager.requestPort:&nbsp;&nbsp;&nbsp;&nbsp; 0<br />Esta entrada DEVE estar comentada para que o XDM possa escutar na porta 177 por pedidos remotos.<br />Existe outro arquivo de configura&ccedil;&atilde;o importante para que o XDM sirva pedidos de login remotos. O arquivo /etc/X11/xdm/Xaccess&nbsp; DEVE conter uma linha que come&ccedil;a com um asterisco '*'. Esta linha &eacute; normalmente incluida no arquivo, mas o Redhat deixa a linha comentada. O script ltsp_initialize consertar&aacute; essa linha para voc&ecirc;, mas se o XDM ainda n&atilde;o parece estar funcionando, voc&ecirc; deve checar este arquivo. Uma linha v&aacute;lida se parece com isso:<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #any host can get a login window<br />KDM<br />Novas vers&otilde;es do KDM t&ecirc;m um arquivo chamdo kdmrc . Diferentes distribui&ccedil;&otilde;es Linux o arquivam em diferentes lugares. No Redhat 7.2, &eacute; /etc/kde/kdm/kdmrc. Em outras distros, voc&ecirc; deve dar o comando locate para achar aonde ele est&aacute;.<br />TA entrada que controla se as esta&ccedil;&otilde;es de traba&ccedil;ho remotas podem obter um login &eacute; a se&ccedil;&atilde;o [Xdmcp]. Tenha certeza que a entrada Enable est&aacute; como true.<br />Vers&otilde;es antigas do KDM usam os arquivos de configura&ccedil;&atilde;o XDM, localizados em /etc/X11/xdm.<br />GDM<br />GDM usa um sistema diferente de arquivos de configura&ccedil;&atilde;o. Eles est&atilde;o localizados no diret&oacute;rio /etc/X11/gdm.<br />O arquivo principal para se olhar &eacute; o gdm.conf. Olhe a se&ccedil;&atilde;o [xdmcp]. Voc&ecirc; pode ver uma entrada naquela se&ccedil;&atilde;o chamada 'Enable'. Deve estar mostrando '1' ou 'true', dependendo da vers&atilde;o do GDM. Aqui est&aacute; um exemplo:<br />[xdmcp]<br />Enable=true<br />HonorIndirect=0<br />MaxPending=4<br />MaxPendingIndirect=4<br />MaxSessions=16<br />MaxWait=30<br />MaxWaitIndirect=30<br />Port=177<br />Note a linha 'Enable=true'. Vers&otilde;es antigas do GDM usam '0' e '1' para dizer se est&atilde;o&nbsp; Disable ou Enable o remoto XDMCP. Novas vers&otilde;es usam 'false' e 'true'.<br />3.Estando o gerenciador de interface gr&aacute;fica definitivamente funcionando, e escutando os pedidos de esta&ccedil;&otilde;es de traba&ccedil;ho remotas, talvez seja um problema simples que ele n&atilde;o consegue mapear o endere&ccedil;o de IP at&eacute; o hostname. As resyta&ccedil;&otilde;es de trabalho precisam ent&atilde;o estar listadas no arquivo /etc/hosts file, ou precisam ser configuradas corretamente nas tabelas de DNS.<br /><br />Cap&iacute;tulo 8. Kernels<br />Existem algumas decis&otilde;es a serem tomadas quanto ao kernel que roda nas esta&ccedil;&otilde;es de trabalho. Voc&ecirc; precisa escolher se quer rodar um dos kernels padr&otilde;es dispon&iacute;veis para dowload, ou construir o seu pr&oacute;prio. E, voc&ecirc; precisa decidir se voc&ecirc; quer mostrar a tela gr&aacute;fica, completa com barra de progresso, que &eacute; poss&iacute;vel pelo Linux Progress Patch (LPP).<br /><br />8.1. Padr&otilde;es&nbsp; de kernels LTSP dispon&iacute;veis<br />O pacote de kernel que vem junto ao&nbsp; LTSP na verdade inclui dois kernels. Um que tem o Linux Progress Patch j&aacute; configurado e rodando, e outro sem o patch.<br />Ambos os kernels t&ecirc;m o patch NFS Swap.<br /><br />8.2. Monte seu pr&oacute;prio kernel<br />Existem duas formas de configurar um kernel para LTSP. O m&eacute;todo padr&atilde;o &eacute; usar algo chamado&nbsp; 'Initial Ram Disk', ou encurtando, o initrd. A imagem initrd &eacute; um pequeno sistema de arquivos que &eacute; pendurado no kernel. A imagem do sistema de arquivos initrd &eacute; aberta na mem&oacute;ria, e uma vez que o ketnel &eacute; inicializado, ir&aacute; montar o disco virtual como o seu sistema de arquivos ra&iacute;z. Existem algumas vantagens em usar uma imagem initrd. Primeiro, n&oacute;s podemos compilar os discos como m&oacute;dulos e rodar o m&oacute;dulo correto durante o bootup. Isso permite com que um simples kernel suporte virtualmente todos os tipos de placas de rede. A outra vantagem &eacute; que podemos rodar o cliente DHCP como um programa &quot;user-land&quot; ao contr&aacute;rio de em kernel-space. Rodando o cliente em user-land permite um melhor controle das op&ccedil;&otilde;es requeridas e recebidas do servidor. E tamb&eacute;m faz com que o kernel fique ligeiramente menor. A outra forma de configurar o kernel &eacute; sem o initrd. Construindo um kernel sem um initrd requer que uma placa de rede espec&iacute;fica esteja estaticamente ligada ao kernel, e tamb&eacute;m requer que IP-Autoconfig e &quot;Root filesystem on NFS&quot; estejam configurados quando construindo o kernel. A vantagem de n&atilde;o usar um initrd &eacute; que o kernel &eacute; ligeiramente menor, &eacute; ir&aacute; inicializar um pouco mais r&aacute;pido. Uma vez que as esta&ccedil;&otilde;es de trabalho est&atilde;o funcionando, n&atilde;o existe muita diferen&ccedil;a em como elas trabalham.<br />O kernel padr&atilde;p para LTSP inclui uma Initial disco virtual (initrd) que cuida de detectar a placa de rede, e fazendo um chamado de espa&ccedil;o para o DHCP. O objetivo maior dessa imagem &eacute; faz&ecirc;-lo o menor poss&iacute;vel. Ent&atilde;o, por isso escolhemos a biblioteca de trocas uClinux libc, e busybox para os utilit&aacute;rios que precisaremos para a inicializa&ccedil;&atilde;o.<br />Se voc&ecirc; quer construir seus pr&oacute;prios kernels, voc&ecirc; deve baixar o pacote ltsp_initrd_kit. Ele cont&eacute;m a hierarquia do sistema de arquivos raiz, e um script para construir a imagem.<br /><br />8.2.1. Obtendo o c&oacute;digo-fonte para o kernel<br />Ao construir um kernel customizado, &eacute; geralmente uma boa id&eacute;ia come&ccedil;ar com fontes de kernel frescas, diretamente do site ftp.kernel.org. A raz&atilde;o para isso &eacute; que distribui&ccedil;&otilde;es como o Redhat, aplicam muitos patches aos c&oacute;digos-fonte de seus kernels, deixando voc&ecirc; com um c&oacute;digo-fonte que na verdade n&atilde;o combina com aquele do kernel oficial.<br />Baixe o pacote-fonte do seu&nbsp; kernel escolhido, e o salve no diret&oacute;rio /usr/src. Os kernels est&atilde;o localizados no diret&oacute;rio /pub/linux/kernel no servidor ftp.kernel.org. Voc&ecirc; deve pegar a recente s&eacute;rie de kernels 2.4.x, porque voc&ecirc; precisa incluir suporte ao devfs.<br />E tamb&eacute;m, se voc&ecirc; quer incluir suporte para trocar o NFS ou o Linux Progress Patch (LPP), voc&ecirc; deve certificar-se que os os patches e os c&oacute;digos-fontes do kernel s&atilde;o os mesmos. Neste momento em que escrevo, o kernel mais recente que d&aacute; apoio &agrave; esses processos &eacute; o 2.4.9.<br />Para o nosso examplo, usaremos o kernel 2.4.9. O caminho completo para ele &eacute;: <a href="ftp://ftp.kernel.org/pub/linux/kernel/v2.4/linux-2.4.9.tar.bz2" title="ftp://ftp.kernel.org/pub/linux/kernel/v2.4/linux-2.4.9.tar.bz2" rel="nofollow">ftp://ftp.kernel.org/pub/linux/kernel/v2.4/linux-2.4.9.tar.bz2</a><br />Desempacote o c&oacute;digo-fonte do kernel no diret&oacute;rio /usr/src. Voc&ecirc; precisa tomar cuidado ao fazer isso j&aacute; que ele estar&aacute; em um diret&oacute;rio chamado linux, e voc&ecirc; talvez j&aacute; tenha um diret&oacute;rio com o mesmo nome com c&oacute;digos-fontes diferentes, e voc&ecirc; n&atilde;o quer bagun&ccedil;&aacute;-lo. Ent&atilde;o procure por um diret&oacute;rio linux existente, e se este houver, nomeie-o diferentemente antes de desempacotar.<br />&nbsp;O pacote-fonte que baixamos foi comprimido com a ferramenta de compress&atilde;o bzip2. Ent&atilde;o devemos desempacot&aacute;-lo antes de o jogarmos no programa tar. Voc&ecirc; pode usar o seguinte comando para desempacot&aacute;-lo:<br />bunzip2 &lt;linux-2.4.9.tar.bz2 | tar xf -<br />Quando o desempacotamento finalizar, voc&ecirc; ter&aacute; um diret&oacute;rio chamado linux contendo toda a &aacute;rvore-fonte. Neste ponto, usualmente renomeia-se o diret&oacute;rio para algo mais informativo.<br />mv linux linux-2.4.9<br />Once the directory has been renamed, then change into the new directory:<br />cd linux-2.4.9<br />Eu normalmente gosto de modificar o Makefile antes de come&ccedil;ar a configurar o novo kernel. No come&ccedil;o dele, est&aacute; uma vari&aacute;vel chamada EXTRAVERSION. Coloco-a como 'ltsp-1', para que o atual n&uacute;mero da vers&atilde;o seja '2.4.9-ltsp-1', o que faz com que o kernel fique facilmente identific&aacute;vel mais tarde. A parte de cima do Makefile deve se parecer com isso quando voc&ecirc; tiver acabado:<br />VERSION = 2<br />PATCHLEVEL = 4<br />SUBLEVEL = 9<br />EXTRAVERSION = -ltsp-1<br /><br />KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)<br /><br />8.2.2. Patches de Kernel<br />Depois de desempacotar o kernel, voc&ecirc; deve ter v&aacute;rios patches que quer aplicar. Por examplo, o NFS Swap patch ou o Linux Progress Patch. Estes patches T&Ecirc;M que ser aplicados antes de configurar o kernel.<br /><br />8.2.2.1. NFS Swap patch<br />O NFS Swap patch permitir&aacute; com que o kernel das esta&ccedil;&otilde;es de trabalho usem um swapfile localizado no servidor NFS. Enquanto &eacute; normalmente recomendado ter mem&oacute;ria suficiente na esta&ccedil;&atilde;o de trabalho para n&atilde;o requerer &aacute;rea de troca, as vezes pode ser dif&iacute;cil adicionar mais mem&oacute;ria, especialmente em computadores velhos. Ent&atilde;o, a habilidade de troca de NFS pode fazer com que um computador que antes era sucata, de fato tornar-se perfeitamente us&aacute;vel.<br />Se o diret&oacute;rio corrente &eacute; o /usr/src/linux-2.4.9, e o patch est&aacute; em /usr/src, voc&ecirc; pode fazer o seguinte teste com ele:<br />patch -p1 --dry-run &lt;../linux-2.4.9-nfs-swap.diff<br />Isso ir&aacute; testar o patch, para certificar-se que ele pode ser aplicado de forma limpa. SE terminar sem erros, ent&atilde;o voc&ecirc; pode aplic&aacute;-lo sem a op&ccedil;&atilde;o --dry-run.<br />patch -p1 &lt;../linux-2.4.9-nfs-swap.diff<br /><br />8.2.2.2. Linux Progress Patch (LPP)<br />O Linux Progress Patch (LPP) permitir&aacute; com que voc&ecirc; configure um logo gr&aacute;fico que aparecer&aacute; durante o processo de inicializa&ccedil;&atilde;o. As mensagens normais de inicializa&ccedil;&atilde;o do kernel s&atilde;o re-direcionadas para uma outra tela tty, e instru&ccedil;&otilde;es especiais s&atilde;o adicionadas aos scripts de inicializa&ccedil;&atilde;o, fazendo com que a barra de progresso reflita o qu&atilde;o longe o processo de inicializa&ccedil;&atilde;o foi.<br />Assim como o patch NFS Swap, voc&ecirc; pode testar o patch LPP por este comando:<br />patch -p1 --dry-run &lt;../lpp-2.4.9<br />Quando o teste completar positivamente, ent&atilde;o voc&ecirc; pode aplicar o patch com:<br />patch -p1 &lt;../lpp-2.4.9<br /><br />8.2.3. Configurando as op&ccedil;&otilde;es de kernel<br />Voc&ecirc; pode agora rodar o programa de configura&ccedil;&atilde;o de kernel de sua prefer&ecirc;ncia. Algumas op&ccedil;&otilde;es s&atilde;o:<br />make xconfig<br />Este ir&aacute; chamar a vers&atilde;o X Windows da ferramenta de configura&ccedil;&atilde;o de kernel.<br />make menuconfig<br />Este ir&aacute; chamar as vers&otilde;es (the curses based version) da ferramenta de configura&ccedil;&atilde;o de kernel.<br />make config<br />Este ir&aacute; chamar a vers&atilde;o simples uma-linha-de-cada-vez da ferramenta de configura&ccedil;&atilde;o de kernel.<br /><br />8.2.3.1. Configura&ccedil;&otilde;es de kernel para usar com initrd<br />Configurar um kernel para usar com initrd requer que as seguintes op&ccedil;&otilde;es estejam presentes:<br />Sistema de arquivos -&gt; suporte ao sistema de arquivos /dev<br />O suporte ao sistema de arquivos /dev dever&atilde;o estar permitidas. Isso &eacute; feito na se&ccedil;&atilde;o 'File systems'. N&Atilde;O especifique 'Automatically mount at boot'. A montagem ser&aacute; feita pelo script /linuxrc.<br />Dispositivos de bloqueio -&gt; suporte &agrave; placa RAM<br />Esta&ccedil;&otilde;es de trabalho LTSP requerem que o kernel suporte uma placa RAM. Isso &eacute; feito na se&ccedil;&atilde;o 'Block devices' (Dispositivos de bloqueio).<br />Dispositivos de bloqueio -&gt; suporte inicial &agrave; placa RAM (initrd)<br />Isso tamb&eacute;m deve estar permitido.<br />Tipo e caracter&iacute;sticas do processador -&gt; fam&iacute;lia do processador<br />Voc&ecirc; deve certificar-se que o kernel que voc&ecirc; construiu pode de fato rodar na CPU da esta&ccedil;&atilde;o de trabalho. Isso &eacute; feito pela se&ccedil;&atilde;o 'Processor type and features'. Voc&ecirc; tamb&eacute;m deve desvalidar (turn off) o apoio a SMP a n&atilde;o ser que voc&ecirc; de fato tenha m&uacute;ltiplas CPUs.<br />Sistema de arquivos -&gt; sistema de arquivos de rede -&gt; suporte a Clientes NFS<br />As esta&ccedil;&otilde;es de trabalho ter&atilde;o seus arquivos de sistema ra&iacute;z montados via NFS, ent&atilde;o suporte a clientes NFS s&atilde;o requiridos.<br />Isto deve dar conta das op&ccedil;&otilde;es requeridas. Voc&ecirc; tamb&eacute;m pode desvalidar muitas op&ccedil;&otilde;es de kernel, para reduzir seu tamanho.<br /><br />8.2.3.2. Configura&ccedil;&otilde;es de kernel para uso sem o initrd<br />Configurando o kernel para uso sem o initrd &eacute; diferente de um kernel com initrd, de algumas formas:<br />Dispositivos de bloqueio -&gt; suporte &agrave; placa RAM<br />Esta&ccedil;&otilde;es de trabalho LTSP requerem que o kernel suporte a placa RAM.<br />Dispositivos de bloqueio -&gt; suporte inicial &agrave; placa RAM (initrd)<br />Este precisa estar desligado.<br />Op&ccedil;&otilde;es de rede -&gt; N&iacute;vel de autoconfigura&ccedil;&atilde;o IP:kernel<br />Este precisa estar ligado. Isso ir&aacute; instruir o kernel a automaticamente configurar a interface ethernet eth0, baseado em valores passados na.<br />N&atilde;o &eacute; necess&aacute;rio especificar as op&ccedil;&otilde;es DHCP, BOOTP ou RARP porque o Etherboot bootrom j&aacute; faz um pedido DHCP ou BOOTP, e far&aacute; com que os par&acirc;metros de IP fiquem dispon&iacute;veis na linha de comando do kernel. Isso faz com que o kernel evite o trabalho de chamar a si mesmo.<br />Suporte a dispositivo de rede -&gt; Ethernet (10 ou 100Mbit)<br />N&atilde;o usando o initrd, voc&ecirc; deve escolher um dispositivo de placa de rede espec&iacute;fico que corresponda &agrave; sua placa de rede. Isso DEVE estar estaticamente conetado ao kernel, porque a interface ethernet &eacute; necess&aacute;ria antes de montar o sistema de arquivos raiz. Essa &eacute; a maior diferen&ccedil;a de um kernel com initrd.<br />Sistemas de arquivo -&gt; suporte a sistemas de arquivo /dev<br />A partir do LTSP vers&atilde;o 2.09pre2, suporte a devfs &eacute; necess&aacute;rio. Isso &eacute; verdade, n&atilde;o importando se o initrd &eacute; usado ou n&atilde;o.<br />Sistemas de arquivo -&gt; montar automaticamente na inicializa&ccedil;&atilde;o<br />N&Atilde;O usando o initrd, o sistema de arquivos /dev deve ser montado pelo kernel, durante o processo de inicializa&ccedil;&atilde;o. Ent&atilde;o diga 'Y' (yes/sim) aqui.<br />Sistemas de arquivo -&gt; sistemas de arquivo de rede -&gt; suporte a cliente NFS<br />As esta&ccedil;&otilde;es de trabalho ter&atilde;o seus sistema de arquivos raiz montados via NFS, ent&atilde;o suporte a clientes NFS &eacute; necess&aacute;rio.<br /><br />8.2.4. Construindo o kernel<br />Para facilitar as coisas, uma c&oacute;pia do arquivo.config est&aacute; incluso no pacote ltsp_initrd_kit. Voc&ecirc; pode copi&aacute;-lo para o diret&oacute;rio /usr/src/linux-2.4.9.<br />Uma vez que voc&ecirc; selecionou ou des-selecionou as op&ccedil;&otilde;es de kernel, voc&ecirc; precisa constru&iacute;-lo. Os comandos a seguir precisam ser executados para construir o kernel:<br />make dep<br />make clean<br />make bzImage<br />make modules<br />make modules_install<br />Voc&ecirc; pode escrev&ecirc;-los em sequ&ecirc;ncia, assim:<br />make dep &amp;&amp; make clean &amp;&amp; make bzImage &amp;&amp; make modules &amp;&amp; make modules_install<br />O sinal duplo (&amp;) significa que se o primeiro comando completar com sucesso, ent&atilde;o o segundo comando ser&aacute; executado. Se o segundo comando for executado com sucesso, ent&atilde;o o terceiro comando ser&aacute; executado, e por a&iacute; vai.<br />Quando a compila&ccedil;&atilde;o de kernel terminar, o novo kernel estar&aacute; em&nbsp; /usr/src/linux-2.4.9/arch/i386/boot/bzImage.<br /><br />8.2.5. Marcando o kernel para Etherboot<br />Para o Etherboot lidar com um kernel Linux, ele precisa estar preparado. Isso &eacute; chamdo de 'Tagging' (Marcar) o kernel. Este processo ir&aacute; adicionar mais c&oacute;digo ao kernel, que por sua vez &eacute; executado antes que o controle passe para ele. A ferramenta para marcar o kernel &eacute; chamada ' mknbi-linux'.<br />O ltsp_initrd_kit inclui um script shell chamado buildk que inclui todos so comandos que voc&ecirc; precisa para preparar a imagem do kernel para iniciliza&ccedil;&atilde;o em rede.<br /><br />Cap&iacute;tulo 9. Entradas lts.conf<br />Quando fizemos o LTSP, um dos assuntos que sab&iacute;amos que ter&iacute;amos que lidar com, era a variedade de configura&ccedil;&otilde;es de hardware das esta&ccedil;&otilde;es de trabalho. Certamente, qualquer combina&ccedil;&atilde;o de processador,&nbsp; placa de rede, e placa de v&iacute;deo dispon&iacute;vel hoje, n&atilde;o mais ocorreria daqui a tr&ecirc;s meses, quando quis&eacute;ssemos adicionar mais esta&ccedil;&otilde;es de trabalho &agrave; rede.<br />Ent&atilde;o, criamos uma maneira de especificar a configura&ccedil;&atilde;o de cada esta&ccedil;&atilde;o de trabalho. Este arquivo de configura&ccedil;&atilde;o &eacute; o lts.conf e fica no diret&oacute;rio /opt/ltsp/i386/etc.<br />O formato do lts.conf permite configura&ccedil;&otilde;es 'padr&otilde;es' assim como uma configura&ccedil;&atilde;o espec&iacute;fica para cada esta&ccedil;&atilde;o de trabalho. Se todas as suas esta&ccedil;&otilde;es de trabalho s&atilde;o id&ecirc;nticas, voc&ecirc; pode especificar todas as suas configura&ccedil;&otilde;es na se&ccedil;&atilde;o padr&atilde;o '[Default]'.<br /><br />9.1. Exemplo de arquivo lts.conf<br />Um exemplo de arquivo lts.conf:<br />[Default]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 192.168.0.254<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_PROTOCOL&nbsp;&nbsp; = &quot;PS/2&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_DEVICE&nbsp;&nbsp;&nbsp;&nbsp; = &quot;/dev/psaux&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_RESOLUTION = 400<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_BUTTONS&nbsp;&nbsp;&nbsp; = 3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USE_XFS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = N<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCREEN_01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = startx<br /><br />[ws001]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = auto<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_PROTOCOL&nbsp;&nbsp; = &quot;Microsoft&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_DEVICE&nbsp;&nbsp;&nbsp;&nbsp; = &quot;/dev/ttyS1&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_RESOLUTION = 50<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_BUTTONS&nbsp;&nbsp;&nbsp; = 3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_MOUSE_BAUD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1200<br /><br />[ws002]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = XF86_Mach64<br /><br />[ws003]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCREEN_01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = shell<br /><br />9.2. Par&acirc;metros lts.conf dispon&iacute;veis<br />9.2.1. Par&acirc;metros gerais<br />Coment&aacute;rios<br />Coment&aacute;rios come&ccedil;am com o sinal '#' e continuam at&eacute; o fim da linha.<br />LTSP_BASEDIR<br />Isso indica onde o sistema de arquivos ra&iacute;z LTSP est&aacute; localizado. O padr&atilde;o &eacute; /opt/ltsp<br />SERVER<br />Este &eacute; o servidor que &eacute; usado para XDM_SERVER, TELNET_HOST, XFS_SERVER e SYSLOG_HOST, caso nenhum destes esteja especificado explicitamente. Se voc&ecirc; tem uma m&aacute;quina que est&aacute; como servidor para tudo, ent&atilde;o voc&ecirc; deve especificar aqui somente o endere&ccedil;o, e omitir os outros par&acirc;metros de servidor. Se este valor n&atilde;o est&aacute; estabelecido, 192.168.0.254 ser&aacute; usado.<br />SYSLOG_HOST<br />Se voc&ecirc; quer mandar mensagens de log para uma m&aacute;quina que n&atilde;o seja o servidor padr&atilde;o, ent&atilde;o voc&ecirc; pode especificar a m&aacute;quina aqui. Caso este par&acirc;metro n&atilde;o seja epecificado, ent&atilde;o ser&aacute; usado o par&acirc;metro 'SERVER' descrito acima.<br />NFS_SERVER<br />Este especifica o endere&ccedil;o IP do servidor NFS usado quando o sistema de arquivos /home&nbsp; &eacute; montado. O padr&atilde;o &eacute; qualquer um que o SERVER esteja configurado para.<br />USE_NFS_SWAP<br />Coloque Y (yes/sim) caso voc&ecirc; queira ativar a troca NFS. O padr&atilde;o &eacute; N (no/n&atilde;o).<br />SWAPFILE_SIZE<br />Este &eacute; como voc&ecirc; controla o tamanho do arquivo de troca (swapfile). O padr&atilde;o &eacute; 64m.<br />SWAP_SERVER<br />O arquivo de troca pode existir em qualquer servidor na rede que &eacute; capaz de lidar com ele. Aqui voc&ecirc; pode especificar o endere&ccedil;o de IP deste servidor. O padr&atilde;o &eacute; qualquer um que o NFS_SERVER esteja indicando.<br />NFS_SWAPDIR<br />O diret&oacute;rio no servidor que est&aacute; sendo exportado via NFS. O padr&atilde;o &eacute; /var/opt/ltsp/swapfiles. Certifique-se que o diret&oacute;rio est&aacute; sendo exportado no arquivo /etc/exports.<br />TELNET_HOST<br />Se a esta&ccedil;&atilde;o de trabalho est&aacute; configurada para ter uma interface de texto, (character based) ent&atilde;o o valor deste par&acirc;metro ser&aacute; usado como hospedeiro para x (hosto to telnet into).&nbsp; Caso este valor N&Atilde;O esteja especificado, ent&atilde;o o valor do SERVER acima ser&aacute; usado.<br />DNS_SERVER<br />Usado para construir o arquivo resolv.conf.<br />SEARCH_DOMAIN<br />Usado para construir o arquivo resolv.conf.<br />SCREEN_01 thru SCREEN_12<br />At&eacute; 12 scripts de tela podem ser especificados para cada esta&ccedil;&atilde;o de trabalho. Isto te permitir&aacute; 12 sess&otilde;es na esta&ccedil;&atilde;o, cada uma acess&iacute;vel pelo clique Ctrl-Alt-F1 atrav&eacute;s das chaves Ctrl-Alt-F12.<br />SCREEN_01&nbsp;&nbsp; = startx<br />SCREEN_02&nbsp;&nbsp; = shell<br />No momento, valores poss&iacute;veis incluem:<br />startx<br />telnet<br />rdesktop<br />shell<br />Olhe o diret&oacute;rio /opt/ltsp/i386/etc/screen.d&nbsp; para mais scripts de tela, ou escreva os seus, e coloque-os aqui.<br />MODULE_01 at&eacute; MODULE_10<br />At&eacute; 10 m&oacute;dulos de kernel podem ser carregados usando estas configura&ccedil;&otilde;es de entrada. A linha de comando inteira que voc&ecirc; usar&aacute; quando rodar insmod pode ser especificada aqui. Por exemplo:<br />MODULE_01&nbsp;&nbsp; = uart401.o<br />MODULE_02&nbsp;&nbsp; = &quot;sb.o io=0x220 irq=5 dma=1&quot;<br />MODULE_03&nbsp;&nbsp; = opl3.o<br />Se o valor desse par&acirc;metro &eacute; um pathname absoluto, ent&atilde;o insmod ser&aacute; usado para carregar o m&oacute;dulo. Ou ent&atilde;o, modprobe ser&aacute; usado.<br />RAMDISK_SIZE<br />Quando as esta&ccedil;&otilde;es de trabalho inicializam, elas criam um disco virtual e montam no diret&oacute;rio /tmp. Voc&ecirc; pode controlar o tamanho do sistema de aqruivo com este par&acirc;metro. Especifique em unidades de kbytes (1024 bytes). Para criar um disco virtual de 1 megabyte, especifique RAMDISK_SIZE = 1024<br />Se voc trocar o tamanho do disco virtual aqui, voc&ecirc; tamb&eacute;m ter&aacute; que trocar o tamanho do disco virtual dentro do kernel. Isso pode ser compilado, ou se voc&ecirc; est&aacute; usando Etherboot ou Netboot, voc&ecirc; diz ao kernel o tamanho do disco virtual quando voc&ecirc; marca o kernel com o mknbi-linux.<br />O valor padr&atilde;o para ela &eacute; 1024 ( 1 mb )<br />RCFILE_01 thru RCFILE_10<br />Outros scripts RC podem ser executados pelo script rc.local. Apenas coloque-o no diret&oacute;rio /etc/rc.d&nbsp; e&nbsp; especifique seu nome em uma dessas entradas.<br />SOUND<br />Se o pacote LTSP Sound est&aacute; instalado, voc&ecirc; precisa colocar nesta entrada Y (yes/sim), e ela executar&aacute; o scrpit rc.sound para configurar a placa de som e o daemon. O padr&atilde;o &eacute; N (no/n&atilde;o).<br /><br />9.2.2. Par&acirc;metros X-Windows<br />XDM_SERVER<br />Caso voc&ecirc; queira apontar XDM para uma outra m&aacute;quina ao inv&eacute;s do servidor padr&atilde;o, voc&ecirc; pode especificar este outro servidor aqui. Se este par&acirc;metro n&atilde;o estiver especificado, ent&atilde;o ser&aacute; usado o par&acirc;metro estabelecido acima em 'SERVER'.<br />XSERVER<br />Este define qual servidor X as esta&ccedil;&otilde;es de trabalho ir&atilde;o rodar. Para placas de v&iacute;deo PCI e AGP, este par&acirc;metro n&atilde;o precisa ser estabelecido. O script rc.local dever&aacute; ser capaz de auto-detectar a placa. Voc&ecirc; tamb&eacute;m pode colocar este valor para auto indicando que deve tentar auto-detectar a placa.<br /><br />Para placas de v&iacute;deo ISA, ou para for&ccedil;ar um servidor X espec&iacute;fico, voc&ecirc; deve especificar o nome do dispositivo ou servidor X nesta entrada.<br />Se esse valor come&ccedil;a com XF86_, ent&atilde;o XFree86 3.3.6 ser&aacute; usado. Ou ent&atilde;o, X.org 6.7.0 ser&aacute; usado. O valor padr&atilde;o &eacute; auto.<br />X_MODE_0 at&eacute; X_MODE_2<br />At&eacute; 3 Modelines ou resolu&ccedil;&otilde;es podem ser configuradas para a esta&ccedil;&atilde;o de trabalho. Esta entrada pode ter dois tipos de valor. Pode ser tanto uma resolu&ccedil;&atilde;o, quanto um modeline completo.<br />X_MODE_0 = 800x600<br /><br />&nbsp;&nbsp; or<br /><br />X_MODE_0 = 800x600 60.75 800 864 928 1088 600 616 621 657 -HSync -VSync<br /><br />Caso nenhuma das entradas X_MODE_x forem especificadas, ent&atilde;o usar&aacute; os modelines emb modelines utidos, e as resolu&ccedil;&otilde;es 1024x768, 800x600 e 640x480.<br />Caso uma ou mais entradas X_MODE_x forem especificadas, elas ir&atilde;o sobrepor-se completamente aos modelines embutidos.<br />X_MOUSE_PROTOCOL<br />Qualquer valor que funcione para a palavra-chave X.org Pointer Protocol pode ser colocada aqui. Valores t&iacute;picos incluem &quot;Microsoft&quot; e &quot;PS/2&quot;. O valor padr&atilde;o &eacute; &quot;PS/2&quot;.<br />X_MOUSE_DEVICE<br />Este &eacute; o dispositivo com o qual o mouse est&aacute; conectado. Se &eacute; um mouse serial, esta deve ser uma porta serial, como /dev/ttyS0 ou /dev/ttyS1. Se &eacute; um mouse de teclado PS/2, este valor ser&aacute; /dev/psaux. O valor padr&atilde;o &eacute; /dev/psaux.<br />X_MOUSE_RESOLUTION<br />Este &eacute; o valor de 'resolu&ccedil;&atilde;o' do arquivo XF86Config. Um valor t&iacute;pico para um mouse serial &eacute; 50 e para um mouse PS/2 400 . O valor padr&atilde;o &eacute; 400.<br />X_BUTTONS<br />Este indica ao sistema quantos bot&otilde;es o mouse t&ecirc;m. Normalmente esta configurado para 2 ou 3. O valor padr&atilde;o &eacute; 3.<br />X_MOUSE_EMULATE3BTN<br />Este indica para o servidor X emular um mouse de 3 bot&otilde;es, aceitando um clique do bot&atilde;o direito e esquerdo ao mesmo tempo. O valor padr&atilde;o &eacute; N (no/n&atilde;o).<br />X_MOUSE_BAUD<br />Para um serial mice, isto define o tempo de x (baud rate). O valor padr&atilde;o &eacute; 1200.<br />X_COLOR_DEPTH<br />Este &eacute; o n&uacute;mero de bits a serem usados para a resolu&ccedil;&atilde;o de cor (color depth). Valores poss&iacute;veis s&atilde;o 8, 15, 16, 24 e 32. 8 bits indicar&aacute; 256 cores, 16 ser&atilde;o 65536 cores, 24 ser&atilde;o 16 milh&otilde;es de cores e 32 bits ser&atilde;o 4.2 bilh&otilde;es de cores! Nem todos os servidores X suportam todos esses valores. O valor padr&atilde;o &eacute; 16<br />USE_XFS<br />Voc&ecirc; pode escolher entre rodar o X Font Server (XFS) ou ler as fontes atrav&eacute;s do sistema de arquivos NFS. O servidor de fontes deve ter uma forma simples de manter todas as fontes em um s&oacute; lugar, mas t&ecirc;m havido alguns problemas quando o n&uacute;mero de esta&ccedil;&otilde;es excede 40. Os 2 valores para esta op&ccedil;&atilde;o s&atilde;o Y (yes/sim) and N (no/n&atilde;o). O valor padr&atilde;o &eacute; N (no/n&atilde;o). Caso voc&ecirc; queira usar um servidor de fontes, voc&ecirc; pode usar a entrada XFS_SERVER para especificar qual hospedeiro ser&aacute; o seu servidor de fonte.<br />XFS_SERVER<br />Caso voc&ecirc; esteja usando o X Font Server para servir fontes, ent&atilde;o voc&ecirc; pode usar esta entrada para especificar o endere&ccedil;o IP do hospedeiro que est&aacute; sendo usado como servidor de fontes. Caso ele n&atilde;o esteja especificado, ir&aacute; usar o servidor padr&atilde;o, que est&aacute; especificado na entrada SERVER acima.<br />X_HORZSYNC<br />Este configura o par&acirc;metro X.org HorizSync . O valor padr&atilde;o &eacute; &quot;31-62&quot;.<br />X_VERTREFRESH<br />Este configura o par&acirc;metro X.org VertRefresh. O valor padr&atilde;o &eacute; &quot;55-90&quot;.<br />XF86CONFIG_FILE<br />Caso voc&ecirc; queira criar todo o seu arquivo XF86Config voc&ecirc; pode fazer isto, e coloc&aacute;-lo no diret&oacute;rio /opt/ltsp/i386/etc. Ent&atilde;o, qualquer um que voc&ecirc; decida chamar deve entrar como um valor para esta vari&aacute;vel de configura&ccedil;&atilde;o. Por exemplo:<br />XF86CONFIG_FILE = XF86Config.ws004<br /><br />9.2.3. Par&acirc;metros de Touch screen<br />USE_TOUCH<br />Se voc&ecirc; est&aacute; conectando uma touch screen &agrave; esta&ccedil;&atilde;o de trabalho, voc&ecirc; pode ativ&aacute;-la configurando esta entrada para Y (yes/sim). Caso ativada, entradas de configura&ccedil;&atilde;o adicionais configurar&atilde;o aspecvtos espec&iacute;ficos da touch screen.&nbsp; O valor padr&atilde;o &eacute; N .<br />X_TOUCH_DEVICE<br />Uma touch screen funciona como um mouse e usualmente est&aacute; conectada &agrave; uma esta&ccedil;&atilde;o de trabalho atrav&eacute;s de uma porta serial. Voc&ecirc; pode especificar qual porta serial com esta entrada. Por exemplo, voc&ecirc; pode deix&aacute;-la igual a /dev/ttyS0.&nbsp; N&atilde;o h&aacute; valor padr&atilde;o para esta entrada.<br />X_TOUCH_MINX<br />Entrada de calibra&ccedil;&atilde;o para uma touch screen EloTouch. O padr&atilde;o &eacute; 433.<br />X_TOUCH_MAXX<br />Entrada de calibra&ccedil;&atilde;o para uma touch screen EloTouch. O padr&atilde;o &eacute; 3588.<br />X_TOUCH_MINY<br />Entrada de calibra&ccedil;&atilde;o para uma touch screen EloTouch. O padr&atilde;o &eacute; 569.<br />X_TOUCH_MAXY<br />Entrada de calibra&ccedil;&atilde;o para uma touch screen EloTouch. O padr&atilde;o &eacute; 3526.<br />X_TOUCH_UNDELAY<br />Entrada de calibra&ccedil;&atilde;o para uma touch screen EloTouch. O padr&atilde;o &eacute; 10.<br />X_TOUCH_RPTDELAY<br />Entrada de calibra&ccedil;&atilde;o para uma touch screen EloTouch. O padr&atilde;o &eacute; 10.<br /><br />9.2.4. Par&acirc;metros Local apps<br />LOCAL_APPS<br />Caso voc&ecirc; deseje&nbsp; ahabilidade de rodar aplicativos localmente em uma esta&ccedil;&atilde;o de trabalho, deixe esta vari&aacute;vel como Y (yes/sim). Muitos passos adicionais devem ser tomados no servidor para permitir local apps. Veja a se&ccedil;&atilde;o 'Local Apps' no manual LTSP para mais informa&ccedil;&otilde;es. O valor padr&atilde;o &eacute; N.<br />NIS_DOMAIN<br />Caso voc&ecirc; configure LOCAL_APPS, ent&atilde;o voc&ecirc; deve ter um servidor NIS na rede. A entrada NIS_DOMAIN &eacute; onde voc&ecirc; especifica o nome de dom&iacute;nio NIS. &Eacute; neces&aacute;rio que combine com um nome de dom&iacute;nio definido no servidor NIS. Isso N&Atilde;O &eacute; a mesma coisa que um nome de dom&iacute;nio de internet.&nbsp; O valor padr&atilde;o &eacute; ltsp.<br />NIS_SERVER<br />Configure este para o endere&ccedil;o de IP do seu servidor NIS caso voc&ecirc; n&atilde;o queira que ele transmita um pedido de servidor NIS.<br /><br />9.2.5. Par&acirc;metros de teclado<br />Todos os arquivos de suporte de teclado est&atilde;o copiados na hierarquia /opt/ltsp/i386, ent&atilde;o configurar suporte de teclado internacional &eacute; feito simplesmente configurando o X.org. Existem uma s&eacute;rie de par&acirc;metros de configura&ccedil;&atilde;o para isso.<br />Os valores para os par&acirc;metros acima s&atilde;o da documenta&ccedil;&atilde;o X.org. O que estiver v&aacute;lido para o X.org &eacute; v&aacute;lido para estes par&acirc;metros.<br />Gostar&iacute;amos de adicionar documenta&ccedil;&atilde;o mostrando quais valores s&atilde;o necess&aacute;rios para cada tipo de teclado internacional. Se voc&ecirc; trabalha com isso e pode configurar seus teclados internacionais, nos contate com esta informa&ccedil;&atilde;o. Ficaremos muito agradecidos.<br />XkbTypes<br />O valor padr&atilde;o &eacute; a palavra 'default '.<br />XkbCompat<br />O valor padr&atilde;o &eacute; a palavra 'default '.<br />XkbSymbols<br />O valor padr&atilde;o &eacute; 'us(pc101)'.<br />XkbModel<br />O valor padr&atilde;o &eacute; 'pc101'.<br />XkbLayout<br />O valor padr&atilde;o &eacute; 'us'.<br /><br />9.2.6. Par&acirc;matros de configura&ccedil;&atilde;o da impressora<br />At&eacute; tr&ecirc;s impressoras podem ser conectadas a uma esta&ccedil;&atilde;o de trabalho sem disco r&iacute;gido. Uma combina&ccedil;&atilde;o de impressoras seriais e paralelas podem ser configuradas pelas entradas do arquivo lts.conf a seguir:<br />PRINTER_0_DEVICE<br />O nome do dispositivo da primeira impressora. Nomes como /dev/lp0, /dev/ttyS0 ou /dev/ttyS1 s&atilde;o permitidos.<br />PRINTER_0_TYPE<br />O tipo de impressora. Escolhas v&aacute;lidas s&atilde;o 'P ' para Paralela, e 'S' para Serial.<br />PRINTER_0_PORT<br />baud rate O n&uacute;mero da porta TCP/IP a ser usada. Por padr&atilde;o, usar&aacute; a ' 9100'<br />PRINTER_0_SPEED<br />Caso a impressora seja serial, esta &eacute; a configura&ccedil;&atilde;o que selecionar&aacute; a baud rate. O padr&atilde;o '9600' ser&aacute; usado.<br />PRINTER_0_FLOWCTRL<br />Para impressoras seriais, o controle de fluxo pode ser especificado. ' S' para controle de fluxo Software (XON/XOFF), ou 'H ' para controle de fluxo Hardware (CTS/RTS). Caso nenhum destes esteja especificado, ' S' ser&aacute; usado.<br />PRINTER_0_PARITY<br />Para impressoras seriais, a Paridade pode ser especificada. As escolhas s&atilde;o: 'E'-Even, 'O'-Odd ou 'N'-None. Caso n&atilde;o seja especificado, 'N' ser&aacute; usado.<br />PRINTER_0_DATABITS<br />Para impressoras seriais, o n&uacute;mero de data bits pode ser especificado. As escolhas s&atilde;o: '5', '6', '7' e '8'. Caso n&atilde;o seja especificado, '8' ser&aacute; usado.<br />PRINTER_1_DEVICE<br />Nome do dispositivo da segunda impressora<br />PRINTER_1_TYPE<br />Tipo de dispositivo da segunda impressora<br />PRINTER_1_PORT<br />Dispositivo&nbsp; de porta TCP/IP da segunda impressora<br />PRINTER_1_SPEED<br />Baud rate (serial) da segunda impressora<br />PRINTER_1_FLOWCTRL<br />Controld de fluxo da segunda impressora (serial)<br />PRINTER_1_PARITY<br />Paridade da segunda impressora (serial)terceira impressora<br />PRINTER_1_DATABITS<br />Data bits da segunda impressora (serial)<br />PRINTER_2_DEVICE<br />Nome do dispositivo da terceira impressora<br />PRINTER_2_TYPE<br />Tipo de dispositivo da terceira impressora<br />PRINTER_2_PORT<br />Porta do dispositivo TCP/IP da terceira impressora<br />PRINTER_2_SPEED<br />Baud rate da terceira impressora (serial)<br />PRINTER_2_FLOWCTRL<br />Controle de fluxo da terceira impressora (serial)<br />PRINTER_2_PARITY<br />Paridade da terceira impressora (serial)<br />PRINTER_2_DATABITS<br />Data bits ad terceira impressora (serial)<br /><br />Cap&iacute;tulo 10. Aplicativos Locais<br />Em um ambiente LTSP, voc&ecirc; pode escolher entre rodar os aplicativos localmente na esta&ccedil;&atilde;o de trabalho, ou remotamente no servidor.<br />De longe, a forma mais f&aacute;cil de configurar um ambiente LTSP &eacute; rodar os aplicativos no servidor. Isso &eacute;, a aplica&ccedil;&atilde;o cliente roda no servidor, usando a CPU e mem&oacute;ria do servidor, enquanto mostra o seu output nas esta&ccedil;&otilde;es de trabalho e usa mouse e teclado da esta&ccedil;&atilde;o de trabalho.<br />Esta &eacute; a capacidade fundamental das Janelas X. As esta&ccedil;&otilde;es de trabalgo trabalham exatamente como um terminal X Windows padr&atilde;o.<br />Para rodar um aplicativo na esta&ccedil;&atilde;o de trabalho, estas precisam saber algumas informa&ccedil;&otilde;es sobre o usu&aacute;rio. Informa&ccedil;&otilde;es como estas:<br />Identidade do usu&aacute;rio<br />Grupo prim&aacute;rio que o usu&aacute;rio pertence<br />O diret&oacute;rio home dos usu&aacute;rios<br />LTSP conta com o Network Information Service - NIS, (formalmente chamado Yellow Pages/P&aacute;ginas Amarelas) para montar a informa&ccedil;&atilde;o de usu&aacute;rios e grupos dispon&iacute;veis nas esta&ccedil;&otilde;es de trabalho.<br /><br />10.1. Benef&iacute;cios de rodar aplicativos localmente<br />Existem benef&iacute;cios de se rodar apliucativos nas esta&ccedil;&otilde;es de trabalho.<br />Reduz o trabalho no servidor. Em redes grandes com aplicativos de mem&oacute;ria intensa, como o Netscape, rodar os aplicativos nas esta&ccedil;&otilde;es de trabalho pode obter uma melhor performance, contanto que as esta&ccedil;&otilde;es de trabalho sejam fortes o suficiente para segurar a onda.<br />Aplicativos fugitivos (runaway) n&atilde;o afetar&atilde;o outros usu&aacute;rios.<br />Suporte a som &eacute; bem mais f&aacute;cil de configurar quando o aplicativo que toca o som est&aacute; rodando nas esta&ccedil;&otilde;es de trabalho.<br /><br />10.2. Considera&ccedil;&otilde;es ao configurar suporte a aplicativos locais<br />Configurar a habilidade de rodar aplicativos localmente requer muito mais.<br />Maior demanda nas esta&ccedil;&otilde;es de trabalho. Ela precisar&aacute; de mais RAM e uma CPU poderosa. 64mb de ram nas esta&ccedil;&otilde;es de trabalho &eacute; um bom come&ccedil;o.<br />NIS &ndash; Para rodar os aplicativos nas esta&ccedil;&otilde;es de trabalho, voc&ecirc; deve primeiramente se identificar nas esta&ccedil;&otilde;es de trabalho. Isso quer dizer que elas precisam saber quem voc&ecirc; &eacute;. Isso requer alguma forma de autentica&ccedil;&atilde;o por senha. NIS foi escolhido como o m&eacute;todo de autentica&ccedil;&atilde;o de usu&aacute;rios pela rede.<br />Diret&oacute;rios adicionais precisam ser exportados das esta&ccedil;&otilde;es de trabalho para serem montados via NFS.<br />Inicializa&ccedil;&atilde;o mais lenta dos aplicativos, porque eles precisam ser lidos via NFS, causando aumento de atividade de rede. E tamb&eacute;m porque cada c&oacute;pia do programa est&aacute; rodando em sua pr&oacute;pria CPU, voc&ecirc; n&atilde;o ter&aacute; a vantagem da habilidade do Linux/Unix de compartilhar segmentos de c&oacute;digo entre m&uacute;ltiplas inst&acirc;ncias do mesmo programa, que reduziria o tempo do segundo e demais chamados do programa.<br /><br />10.3. Configura&ccedil;&otilde;es do servidor para aplicativos locais<br />10.3.1. Entradas lts.conf<br />Algumas poucas entradas t&ecirc;m que ser configuradas no arquivo lts.conf:<br />LOCAL_APPS<br />Precisam estar como Y (yes/sim). Isso ir&aacute; provocar o seguinte processo nas esta&ccedil;&otilde;es do trabalho durante o processo de inicializa&ccedil;&atilde;o:<br />1.O diret&oacute;rio /home&nbsp; no servidor ser&aacute; montado via NFS.<br />2. /var/yp/nicknames ser&aacute; criado nas esta&ccedil;&otilde;es de trabalho.<br />3.O portmapper ser&aacute; iniciado nas esta&ccedil;&otilde;es de trabalho.<br />4.xinetd ser&aacute; iniciado nas esta&ccedil;&otilde;es de trabalho.<br />5.O arquivo /etc/yp.conf ser&aacute; criado nas esta&ccedil;&otilde;es de trabalho.<br />6.O comando domainname rodar&aacute; com o valor da entrada do lts.conf NIS_DOMAIN.<br />7.O ypbind rodar&aacute; nas esta&ccedil;&otilde;es de trabalho.<br /><br />NIS_DOMAIN<br />Com NIS, todos os nodos da rede que querem se associar com um servidor NIS espec&iacute;fico precisam pertencer ao mesmo dom&iacute;nio NIS (isso n&atilde;o se relaciona de nehuma forma com o dom&iacute;nio DNS). Voc&ecirc; usa a entrada NIS_DOMAIN para especificar o nome do dom&iacute;nio NIS do qual a esta&ccedil;&otilde;es de trabalho far&atilde;o parte.<br />NIS_SERVER<br />NIS tentar&aacute; usar um servidor NIS espec&iacute;fico, ou mandar&aacute; um chamado para a rede, procurando por um servidor. Se voc&ecirc; quer escolher um servidor espec&iacute;fico, ent&atilde;o coloque o endere&ccedil;o de IP deste servidor na entrada NIS_SERVER.<br /><br />10.3.2. Nesta&ccedil;&otilde;es de trabalhoetwork Information Service - NIS<br />NIS &eacute; um tipo de servi&ccedil;o Client/Server. No servidor, existe um daemon rodando, que aceitar&aacute; chamados de clientes (esta&ccedil;&otilde;es de trabalho). Este daemon no servidor &eacute; chamado ypserv.<br />Nas esta&ccedil;&otilde;es de trabalho, existe um processo chamado ypbind. Quando as esta&ccedil;&otilde;es de trabalho precisam checar informa&ccedil;&atilde;o sobre um usu&aacute;rio, como verificar uma senha ou achar seu diret&oacute;rio home, usar&aacute; ypbind para estabelecer uma conex&atilde;o com ypserv, no servidor.<br />Se voc&ecirc; j&aacute; est&aacute; rodando NIS no seu ambiente de rede, ent&atilde;o n&atilde;o &eacute; necess&aacute;rio configurar o servidor LTSP para tamb&eacute;m rodar ypserv. Voc&ecirc; s&oacute; precisa configurar o NIS_DOMAINNAME e as entradas&nbsp; NIS_SERVER em lts.conf para combinar com o seu esquema NIS.<br />Se voc&ecirc; N&Atilde;O est&aacute; rodando NIS em sua rede, ent&atilde;o voc&ecirc; ter&aacute; que configurar o servidor para rodar&nbsp; ypserv.<br />Para informa&ccedil;&otilde;es completas sobre a configura&ccedil;&atilde;o de um servidor NIS, cheque o documento HOWTO do site LDP chamado The Linux NIS(YP)/NYS/NIS+ HOWTO. Olhe a lista de outras fontes de informa&ccedil;&atilde;o ao final deste documento.<br /><br />10.4. Configura&ccedil;&otilde;es de aplicativos<br />Ao configurar um aplicativo para rodar nas esta&ccedil;&otilde;es de trabalho, voc&ecirc; deve colocar todos os componentes deste aplicativo em um lugar que a esta&ccedil;&atilde;o de trabalho possa ver.<br />Com vers&otilde;es antigas de LTSP (2.08 e anteriores), muitos diret&oacute;rios eram exportados para o servidor e montados pela esta&ccedil;&atilde;o de trabalho. Diret&oacute;rios como /bin, /usr/bin , /lib e /usr eram expostos para a esta&ccedil;&atilde;o de trabalho.<br />O problema com este esquema &eacute; que ele funciona apenas se a esta&ccedil;&atilde;o de trabalho e o servidor s&atilde;o a mesma arquitetura. De fato, at&eacute; diferen&ccedil;as como o servidor ser um Pentium II (i686) e as esta&ccedil;&otilde;es de trabalho serem um Pentium (i586) cl&aacute;ssico podem ser um problema, porque o servidor provavelmente ter&aacute; bibliotecas i686 e n&atilde;o bibliotecas i386, i486 ou i586.<br />Ent&atilde;o, a forma mais limpa de se lidar com isso &eacute; ter uma &aacute;rvore completa com todos os bin&aacute;rios e bibliotecas que a esta&ccedil;&atilde;o de trabalho precisar&aacute;, independente dos bin&aacute;rios e bibliotecas do servidor.<br />Configurando um aplicativo para uma execu&ccedil;&atilde;o local requer colocar todas as pe&ccedil;as requeridas nesta &aacute;rvore. Um dos pacotes dispon&iacute;veis para baixar do site LTSP &eacute; o pacote Local netscape, que instala&nbsp; v&aacute;rios arquivos no diret&oacute;rio /opt/ltsp/i386/usr/local/netscape. Coisas como aulas de java (java classes), arquivos de ajuda, arquivos bin&aacute;rios execut&aacute;veis e scripts s&atilde;o colocados aqui.<br />Netscape n&atilde;o precisa de nenhum sistema de biblioteca adicional, ent&atilde;o n&atilde;o h&aacute; nada a adicionar ao diret&oacute;rio /opt/ltsp/i386/lib. Muitos aplicativos requerem bibliotecas adicionais.<br />Ent&atilde;o, como voc&ecirc; pode determinar quais bibliotecas precisa? Eis que a resposta sureg no comando ldd.<br />Vamos pressupor que voc&ecirc; quer configurar um certo aplicativo para rodar localmente. Vamos dizer o gaim, por exemplo. gaim &eacute; um cliente de mensageiro instant&acirc;neo da AOL, que permite com que voc&ecirc; se comunique com outras pessoas nos f&oacute;runs AOL. ???!!<br />A primeira coisa que voc&ecirc; precisa fazer &eacute; achar o arquivo bin&aacute;rio execut&aacute;vel gaim. No sistema Redhat 7.2, ele est&aacute; localizado no diret&oacute;rio /usr/bin.<br />Uma vez que voc&ecirc; localizou o bin&aacute;rio gaim, voc&ecirc; pode rodar ldd para ver suas depend&ecirc;ncias:<br />[jam@server /]$ ldd /usr/bin/gaim<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libaudiofile.so.0&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libaudiofile.so.0 (0x40033000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libm.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /lib/i686/libm.so.6 (0x40051000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libnsl.so.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /lib/libnsl.so.1 (0x40074000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgnomeui.so.32&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libgnomeui.so.32 (0x4008a000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libart_lgpl.so.2&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libart_lgpl.so.2 (0x4015d000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgdk_imlib.so.1&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libgdk_imlib.so.1 (0x4016c000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libSM.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/X11R6/lib/libSM.so.6 (0x40191000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libICE.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/X11R6/lib/libICE.so.6 (0x4019a000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgtk-1.2.so.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libgtk-1.2.so.0 (0x401b1000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libdl.so.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /lib/libdl.so.2 (0x402df000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgdk-1.2.so.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libgdk-1.2.so.0 (0x402e3000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgmodule-1.2.so.0&nbsp; =&gt; /usr/lib/libgmodule-1.2.so.0 (0x40319000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libXi.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/X11R6/lib/libXi.so.6 (0x4031d000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libXext.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/X11R6/lib/libXext.so.6 (0x40325000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libX11.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/X11R6/lib/libX11.so.6 (0x40333000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgnome.so.32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libgnome.so.32 (0x40411000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libgnomesupport.so.0 =&gt; /usr/lib/libgnomesupport.so.0 (0x40429000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libesd.so.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libesd.so.0 (0x4042e000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libdb.so.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libdb.so.2 (0x40436000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libglib-1.2.so.0&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libglib-1.2.so.0 (0x40444000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libcrypt.so.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /lib/libcrypt.so.1 (0x40468000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libc.so.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /lib/i686/libc.so.6 (0x40495000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libz.so.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; /usr/lib/libz.so.1 (0x405d1000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /lib/ld-linux.so.2&nbsp;&nbsp; =&gt; /lib/ld-linux.so.2 (0x40000000)<br />A listagem acima mostra todas as bibliotecas que o programa gaim est&aacute; dinamicamente dependente.<br />A maior parte dos programas que usam bibliotecas compartilhadas, confiam no din&acirc;mico buscador (loader) ld-linux para localizar e baixar cada uma das bibliotecas compartilhadas. Alguns programas, no entanto, baixam as bibliotecas manualmente com a fun&ccedil;&atilde;o de chamado dlopen(). Para estes aplicativos, ldd n&atilde;o mostrar&aacute; as bibliotecas. Neste caso, strace pode ser usado para tra&ccedil;ar a execu&ccedil;&atilde;o de um programa, e voc&ecirc; ver&aacute; os chamados de dlopen(), com o nome da biblioteca listada nos argumentos.<br />Uma vez que a lista de bibliotecas foi coletada, as bibliotecas requeridas precisar&atilde;o ser copiadas para seus lugares apropriados na &aacute;rvore /opt/ltsp/i386.<br /><br />10.5. Ativando aplicativos locais<br />Nas janelas X, programas rodam tipicamente relativos ao lugar em que o gerenciador de janelas roda. Isso significa que se o gerenciador de janelas est&aacute; rodando no servidor, mostrando o seu resultado (output) nas esta&ccedil;&otilde;es de trabalho, ent&atilde;o quaisquer programas que forem ativados, tamb&eacute;m rodar&atilde;o no servidor, mandando o seu output para a esta&ccedil;&atilde;o de trabalho.<br />O truque &eacute; ter o servidor informando as esta&ccedil;&otilde;es de trabalho para ativar o programa. Isso &eacute; tipicamente feito com o comando rsh.<br />Aqui est&aacute; um exemplo de com o rodar o programa gaim em uma esta&ccedil;&atilde;o de trabalho:<br />HOST=`echo $DISPLAY | awk -F: '{ print $1 }'`<br />rsh ${HOST} /usr/bin/gaim -display ${DISPLAY}<br />O examplo acima pode ser inserido em uma janela xterm, ou pode ser colocado em um script shell,e&nbsp; ser ativado por um &iacute;cone na &aacute;rea de trabalho.<br />Ativando o local Netscape &eacute; feito de forma parecida, mas uma vari&aacute;vel ambiente adicional precisa ser estabelecida, antes de rodar o programa.<br />HOST=`echo $DISPLAY | awk -F: '{ print $1 }'`<br />rsh ${HOST} MOZILLA_HOME=/usr/local/netscape \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/local/netscape/netscape -display ${DISPLAY}<br /><br />Cap&iacute;tulo 11. Exemplos de configura&ccedil;&atilde;o<br />Praticamente qualquer aspecto de uma esta&ccedil;&atilde;o de trabalho pode ser configurada com entradas no lts.conf, que &eacute; normalmente localizado no diret&oacute;rio /opt/ltsp/i386/etc.<br /><br />11.1. Mouse Serial<br />Este &eacute; um exemplo de uma entrada lts.conf para um mouse padr&atilde;o serial de 2 bot&otilde;es:<br />X_MOUSE_PROTOCOL&nbsp;&nbsp;&nbsp; = &quot;Microsoft&quot;<br />X_MOUSE_DEVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &quot;/dev/ttyS0&quot;<br />X_MOUSE_RESOLUTION&nbsp; = 400<br />X_MOUSE_BUTTONS&nbsp;&nbsp;&nbsp;&nbsp; = 2<br />X_MOUSE_EMULATE3BTN = Y<br /><br />11.2. Mouse PS/2 (Wheel mouse)<br />Este &eacute; um exemplo de uma entrada lts.conf para um Intellimouse:<br />X_MOUSE_PROTOCOL&nbsp;&nbsp;&nbsp; = &quot;IMPS/2&quot;<br />X_MOUSE_DEVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &quot;/dev/psaux&quot;<br />X_MOUSE_RESOLUTION&nbsp; = 400<br />X_MOUSE_BUTTONS&nbsp;&nbsp;&nbsp;&nbsp; = 5<br />X_ZAxisMapping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &quot;4 5&quot;<br /><br />11.3. Impressora USB em uma ThinkNic<br />A esta&ccedil;&atilde;o de trabalho ThinkNIC tem uma porta USB, que pode ser usada para conectar uma impressora local. Este &eacute; um exemplo de entrada requerida no arquivo lts.conf:<br />MODULE_01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = usb-ohci<br />MODULE_02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = printer<br />PRINTER_0_DEVICE&nbsp;&nbsp;&nbsp; = /dev/usb/lp0<br />PRINTER_0_TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = S<br /><br />11.4. For&ccedil;ando uma esta&ccedil;&atilde;o de trabalho a rodar um servidor X Free86 3.3.6 X<br />Por padr&atilde;o, X.org 6.7.0 ser&aacute; usado na esta&ccedil;&atilde;o de trabalho. Se voc&ecirc; quer for&ccedil;ar a esta&ccedil;&atilde;o de trabalho a usar uma vers&atilde;o mais antiga como o servidor X XFree86 3.3.6, voc&ecirc; ter&aacute; que primeiro ativar o pacote&nbsp; 3.3.6 Xserver. Ent&atilde;o, voc&ecirc; dever&aacute; adicionar a entrada no arquivo lts.conf. Este &eacute; um exemplo para especificar um servidor X SVGA:<br />XSERVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = XF86_SVGA<br /><br />Cap&iacute;tulo 12. Outras fontes de informa&ccedil;&atilde;o<br />12.1. Refer&ecirc;ncias Online<br />1.O site oficial LTSP<br />www.LTSP.org<br />2.O documento para Linux Diskless-Nodes HOW-TO<br />www.linuxdoc.org/HOWTO/Diskless-HOWTO.html<br />3.P&aacute;gina do Etherboot<br />etherboot.sourceforge.net<br />4.Site Rom-O-Matic<br />www.Rom-O-Matic.net<br />5.Suporte para Mouse X.org<br />www.xfree86.org/current/mouse.html<br />6.XFree86-Video-Timings-HOWTO<br />www.linuxdoc.org/HOWTO/XFree86-Video-Timings-HOWTO.html<br />7.Linux NIS(YP)/NYS/NIS+ HOWTO<br />www.linuxdoc.org/HOWTO/NIS-HOWTO.html<br /><br />12.2. Publica&ccedil;&otilde;es Impressas<br />1.Managing NFS and NIS<br />Hal Stern<br />O'Reilly &amp; Associates, Inc.<br />1991<br />ISBN 0-937175-75-7<br /><br />2.TCP/IP Illustrated, Volume 1<br />W. Richard Stevens<br />Addison-Wesley<br />1994<br />ISBN 0-201-63346-9<br /><br />3.X Window System Administrator's Guide<br />Linda Mui and Eric Pearce<br />O'Reilly &amp; Associates, Inc.<br />1993<br />ISBN 0-937175-83-8<br />(Volume 8 of the The Definitive Guides to the X Window System)</p>  </div>

  <ul class="links inline"><li class="statistics_counter first last"><span>3529 leituras</span></li>
</ul></div> <!-- /.node -->
        </div>

        
        
      </div></div> <!-- /.section, /#content -->

      
      <div class="region region-sidebar-second column sidebar"><div class="section">
  <div id="block-blog-0" class="block block-blog first region-odd odd region-count-1 count-1">
      <h2 class="title">Posts recentes no blog</h2>
  
  <div class="content">
    <div class="item-list"><ul><li class="first"><a href="../blog/21-01-16/Servindo-arquivos-com-ipfs.html">Servindo arquivos com ipfs</a></li>
<li><a href="../blog/21-11-15/A-culpa-e-de-quem-hein.html">A culpa é de quem, hein?</a></li>
<li><a href="../blog/03-08-14/Experiencias-Sonoras.html">Experiências Sonoras</a></li>
<li><a href="../blog/08-07-14/Redes-sociais-livres-ou-alternativas.html">Redes sociais livres ou alternativas?</a></li>
<li><a href="../blog/30-06-14/Premio-do-Objeto-Brasileiro-drones-DIY.html">Prêmio do Objeto Brasileiro, drones, DIY</a></li>
<li><a href="../blog/03-06-14/Dividir-para-multiplicar.html">Dividir para multiplicar</a></li>
<li><a href="../blog/10-04-14/O-que-rolou-no-IoTDay-Riacho.html">O que rolou no IoTDay Riacho</a></li>
<li><a href="../blog/22-03-14/A-viola-eletrica.html">A viola elétrica</a></li>
<li><a href="../blog/22-03-14/Semana-da-Agua-Ultimo-dia-e-exibicao-na-Prainha.html">Semana da Água: Último dia e exibição na Prainha</a></li>
<li class="last"><a href="../blog/21-03-14/Semana-da-Agua-dia-5-com-Iniciativa-Verde.html">Semana da Água: dia 5 com Iniciativa Verde</a></li>
</ul></div><div class="more-link"><a href="../blog.html" title="Ler os posts mais novos.">more</a></div>  </div>

  </div><!-- /.block -->
<div id="block-comment-0" class="block block-comment region-even even region-count-2 count-2">
      <h2 class="title">Comentários recentes</h2>
  
  <div class="content">
    <div class="item-list"><ul><li class="first"><a href="Zonas-de-Colabora%c3%a7%c3%a3o.html#comment-353">Falando de Meio Ambiente</a><br />1 ano 31 semanas atrás</li>
<li><a href="../blog/17-03-14/Abertura-da-Semana-da-Agua-no-Lago-Azul.html#comment-352">Metarecicleirxs</a><br />2 anos 6 dias atrás</li>
<li><a href="../blog/05-03-14/Presente-do-preterito.html#comment-351">Sim</a><br />2 anos 2 semanas atrás</li>
<li><a href="../blog/01-12-13/Reuso-de-recipientes-de-Arla32.html#comment-350">Obrigado, seguindo a pesquisa</a><br />2 anos 16 semanas atrás</li>
<li><a href="../blog/01-12-13/Reuso-de-recipientes-de-Arla32.html#comment-349">Reuso de Tambores e afins</a><br />2 anos 16 semanas atrás</li>
<li><a href="../blog/07-11-13/Quilombo-da-Fazenda-3.html#comment-348">Reciclagem é coisa Séria</a><br />2 anos 18 semanas atrás</li>
<li><a href="../blog/07-11-13/Quilombo-da-Fazenda-3.html#comment-347">&lt;quote&gt;Usei todas as palavras</a><br />2 anos 19 semanas atrás</li>
<li><a href="../blog/07-11-13/Quilombo-da-Fazenda-3.html#comment-346">oi Joselino, entra na conversa ai</a><br />2 anos 19 semanas atrás</li>
<li><a href="../blog/07-11-13/Quilombo-da-Fazenda-3.html#comment-345">Agradecimentos</a><br />2 anos 19 semanas atrás</li>
<li class="last"><a href="../blog/07-11-13/Quilombo-da-Fazenda-3.html#comment-344">A Fenix ressurge das cinzas...</a><br />2 anos 19 semanas atrás</li>
</ul></div>  </div>

  </div><!-- /.block -->
<div id="block-views-b9a9b32880857eafcdc9edb821bdf484" class="block block-views last region-odd odd region-count-3 count-3">
      <h2 class="title">Mudanças recentes no wiki</h2>
  
  <div class="content">
    <div class="views_view view view-recentchanges-wiki-bloco view-id-recentchanges_wiki_bloco view-display-id-block_1 view-dom-id-1">
  
      <div class="view-header">
      <p>Altera&ccedil;&otilde;es recentes no wiki deste site. Essa p&aacute;gina tamb&eacute;m tem uma vers&atilde;o <a href="../listas/MudancasRecentes/feed">RSS</a>.</p>
<div style="display:none;"><a href="http://calc.name/"><b>Calculatrice</b></a> en ligne: un chiffre rond, multiplier, diviser, soustraire, ajouter des numeros, tangente, sinus, cosinus, cotangente.</div>    </div>
  
  
  
      <div class="view-content">
      <div class="item-list">
    <ul>
          <li class="views-row views-row-1 views-row-odd views-row-first">  
  <div class="views-field-title">
                <span class="field-content"><a href="Livre-se-da-Google.html">Livre-se da Google!</a></span>
  </div>
  
  <div class="views-field-changed">
                <span class="field-content">há <em>6 semanas 15 horas</em></span>
  </div>
</li>
          <li class="views-row views-row-2 views-row-even">  
  <div class="views-field-title">
                <span class="field-content"><a href="Proposta-Festival-CulturaDigitalBr-2011.html">Proposta Festival CulturaDigital.Br 2011</a></span>
  </div>
  
  <div class="views-field-changed">
                <span class="field-content">há <em>6 semanas 15 horas</em></span>
  </div>
</li>
          <li class="views-row views-row-3 views-row-odd">  
  <div class="views-field-title">
                <span class="field-content"><a href="InicioWiki.html">InicioWiki</a></span>
  </div>
  
  <div class="views-field-changed">
                <span class="field-content">há <em>9 semanas 5 dias</em></span>
  </div>
</li>
          <li class="views-row views-row-4 views-row-even">  
  <div class="views-field-title">
                <span class="field-content"><a href="P%c3%a1gina-de-refer%c3%aancia-pras-oficinas.html">Página de referência pras oficinas</a></span>
  </div>
  
  <div class="views-field-changed">
                <span class="field-content">há <em>9 semanas 5 dias</em></span>
  </div>
</li>
          <li class="views-row views-row-5 views-row-odd views-row-last">  
  <div class="views-field-title">
                <span class="field-content"><a href="Mae-d%e2%80%99Agua.html">Mãe d’Agua</a></span>
  </div>
  
  <div class="views-field-changed">
                <span class="field-content">há <em>10 semanas 11 horas</em></span>
  </div>
</li>
      </ul>
</div>    </div>
  
  
  
  
  
  
</div><!-- /.view -->
  </div>

  </div><!-- /.block -->
</div></div><!-- /.section, /.region -->

    </div></div> <!-- /#main, /#main-wrapper -->
  </div></div> <!-- /#page, /#page-wrapper -->

      <div id="footer-wrapper"><div id="footer"><div class="section">

      
              <div id="footer-message"><p>conte&uacute;do copyleft - use sabiamente e mencione a fonte</p></div>
      
      
    </div></div></div> <!-- /.section, /#footer -->
  
  
  
</body>

<!-- Mirrored from rede.metareciclagem.org/wiki/LtspTraducaoTati by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 23 Mar 2016 23:42:09 GMT -->
</html>
